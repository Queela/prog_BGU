&НаКлиенте
Перем ЗначениеТочкиВходаПроцедуры;

&НаСервере
Перем ПриоритетыОпераций;

// Licensed with
// https://github.com/Lead-Tools/ripper/blob/master/LICENSE
&НаСервере
Function Parse(Src, Pos = 1) Export
	List = New Array;
	Pos = Pos + 1;
	Chr = Mid(Src, Pos, 1);
	If Chr = Chars.LF Then
		Pos = Pos + 1;
		Chr = Mid(Src, Pos, 1);
	EndIf;
	Beg = Pos;
	While Chr <> "" Do
		If Chr = "{" Then
			List.Add(Parse(Src, Pos));
			Pos = Pos + 1;
			Chr = Mid(Src, Pos, 1);
			If Chr = Chars.LF Then
				Pos = Pos + 1;
				Chr = Mid(Src, Pos, 1);
			EndIf;
			Beg = Pos;
		ElsIf Chr = "," Then
			If Beg < Pos Then
				List.Add(Mid(Src, Beg, Pos - Beg));
			EndIf;
			Pos = Pos + 1;
			Chr = Mid(Src, Pos, 1);
			If Chr = Chars.LF Then
				Pos = Pos + 1;
				Chr = Mid(Src, Pos, 1);
			EndIf;
			Beg = Pos;
		ElsIf Chr = "}" Then
			If Beg < Pos Then
				List.Add(Mid(Src, Beg, Pos - Beg));
			EndIf;
			Break;
		ElsIf Chr = """" Then
			While Chr = """" Do
				Pos = Pos + 1;
				While Mid(Src, Pos, 1) <> """" Do
					Pos = Pos + 1;
				EndDo;
				Pos = Pos + 1;
				Chr = Mid(Src, Pos, 1);
			EndDo;
		Else
			Pos = Pos + 1;
			Chr = Mid(Src, Pos, 1);
		EndIf;
	EndDo;
	Return List;
EndFunction // Parse()

&НаСервере
Процедура ПриСозданииНаСервере(Отказ, СтандартнаяОбработка)
	РасшифровкаОперацийТЗ = ЗагрузитьРасшифровкуБайтКода();
	ЗаполнитьСписокОпКодов(РасшифровкаОперацийТЗ);
	ЗначениеВРеквизитФормы(РасшифровкаОперацийТЗ, "РасшифровкаОпераций");
КонецПроцедуры


&НаСервере
Процедура ОткрытьНаСервере(Знач Адрес)
	
	Операции.Очистить();
	ЭтаФорма.Константы.Очистить();
	Переменные.Очистить();
	Процедуры.Очистить();
	
	РезультатРазбора = ПрочитатьМодуль(Адрес);

	Для Сч = 1 По РезультатРазбора.ВГраница() Цикл
		Блок = РезультатРазбора[Сч];
		Если Блок[0] = """Cmd""" Тогда
			ЗаполнитьОперации(Блок);
		ИначеЕсли Блок[0] = """Const""" Тогда
			ЗаполнитьКонстанты(Блок);
		ИначеЕсли Блок[0] = """Var""" Тогда
			ЗаполнитьПеременные(Блок, Переменные);
		ИначеЕсли Блок[0] = """Proc""" Тогда
			ЗаполнитьПроцедуры(Блок);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

&НаСервере
Процедура ЗаполнитьОперации(Знач Блок)

	ЧислоКоманд = Число(Блок[1]);
	ТочкаВхода = Число(Блок[2]);
	СчетчикАдресов = 0;
	Для Сч = 3 По ЧислоКоманд+2 Цикл
		Команда = Блок[Сч];
		СтрокаОперации = Операции.Добавить();
		СтрокаОперации.Адрес = СчетчикАдресов;
		Если СчетчикАдресов = ТочкаВхода Тогда
			СтрокаОперации.ЭтоТочкаВхода = 1;
		КонецЕсли;
		СтрокаОперации.КодОперации = Число(Команда[0]);
		СтрокаОперации.Аргумент = Число(Команда[1]);
		Если СтрокаОперации.КодОперации < РасшифровкаОпераций.Количество() Тогда
			СтрокаОписания = РасшифровкаОпераций[СтрокаОперации.КодОперации];
			СтрокаОперации.ИмяОперации = СтрокаОписания.Мнемоника;
			СтрокаОперации.Описание = СтрокаОписания.Название + Символы.ПС + СтрокаОписания.ОписаниеАргумента;
		Иначе
			СтрокаОперации.ИмяОперации = СтрокаОперации.КодОперации;
			СтрокаОперации.Описание = "ОпКод еще не исследован";
		КонецЕсли;
		
		СчетчикАдресов = СчетчикАдресов + 1;
	КонецЦикла;

КонецПроцедуры // ЗаполнитьОперации()

&НаСервере
Процедура ЗаполнитьСписокОпКодов(Знач РасшифровкаОпераций)

	Элемент = Элементы.ОперацииИмяОперации;
	Для Каждого Стр Из РасшифровкаОпераций Цикл
		Элемент.СписокВыбора.Добавить(Стр.Мнемоника);
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьСписокОпКодов()

&НаСервере
Процедура ЗаполнитьКонстанты(Знач Блок)

	Типы = Новый Соответствие;
	Типы.Вставить("""N""", "Число");
	Типы.Вставить("""S""", "Строка");
	Типы.Вставить("""B""", "Булево");
	Типы.Вставить("""D""", "Дата");
	Типы.Вставить("""L""", "Null");
	Типы.Вставить("""U""", "Неопределено");
	
	ЧислоКонстант = Число(Блок[1]);
	Счетчик = 0;
	Для Сч = 2 По ЧислоКонстант+1 Цикл
		Константа = Блок[Сч];
		СтрКонстанты = ЭтаФорма.Константы.Добавить();
		СтрКонстанты.Номер = Счетчик;
		СтрКонстанты.ТипКонстанты = Типы[Константа[0]];
		Если СтрКонстанты.ТипКонстанты = "Дата" Тогда
			СтрКонстанты.Значение = Константа[1];
		Иначе
			СтрКонстанты.Значение = ДесериализоватьСтроку(Константа[1]);
		КонецЕсли;
		Счетчик = Счетчик + 1;
	КонецЦикла;

КонецПроцедуры // ЗаполнитьКонстанты()

&НаСервере
Процедура ЗаполнитьПеременные(Знач Блок, Знач ТаблицаПриемник)

	ЧислоПеременных = Число(Блок[1]);
	Для Сч = 2 По ЧислоПеременных + 1 Цикл
		Переменная = Блок[Сч];
		СтрПерем = ТаблицаПриемник.Добавить();
		СтрПерем.ИмяПеременной = СтрЗаменить(Переменная[0],"""", "");
		СтрПерем.ФлагиПеременной = Число(Переменная[1]);
	КонецЦикла;

КонецПроцедуры // ЗаполнитьПеременные()

&НаСервере
Процедура ЗаполнитьМеткиПерехода(Знач Блок, Знач ТаблицаПриемник)

	ЧислоПеременных = Число(Блок[1]);
	Для Сч = 2 По ЧислоПеременных + 1 Цикл
		Переменная = Блок[Сч];
		СтрПерем = ТаблицаПриемник.Добавить();
		СтрПерем.ИмяМетки = СтрЗаменить(Переменная[0],"""", "");
		СтрПерем.НомерОперации = Число(Переменная[1]);
	КонецЦикла;

КонецПроцедуры // ЗаполнитьПеременные()

&НаСервере
Процедура ЗаполнитьПроцедуры(Знач Блок)

	ЧислоПроцедур = Число(Блок[1]);
	Счетчик = 0;
	Для Сч = 2 По ЧислоПроцедур + 1 Цикл
		
		Проц = Блок[Сч];
		СтрокаПроцедуры = Процедуры.Добавить();
		СтрокаПроцедуры.Номер = Счетчик;
		СтрокаПроцедуры.ИмяПроцедуры = СтрЗаменить(Проц[0],"""", "");
		СтрокаПроцедуры.ТипПроцедуры = Число(Проц[1]);
		СтрокаПроцедуры.ЧислоАргументов = Число(Проц[2]);
		СтрокаПроцедуры.ТочкаВхода = Число(Проц[3]);
		
		Если СтрокаПроцедуры.ТипПроцедуры < 32 Тогда
			Операция = Операции[СтрокаПроцедуры.ТочкаВхода];
			Операция.ЭтоТочкаВхода = 2;
		КонецЕсли;
		
		Для СчОпциональный = 4 По Проц.ВГраница() Цикл
			Если Проц[СчОпциональный][0] = """Lbl""" Тогда
				ЗаполнитьМеткиПерехода(Проц[СчОпциональный], СтрокаПроцедуры.МеткиПерехода);
			КонецЕсли;
			Если Проц[СчОпциональный][0] = """Var""" Тогда
				ЗаполнитьПеременные(Проц[СчОпциональный], СтрокаПроцедуры.Переменные);
			КонецЕсли;
			Если Проц[СчОпциональный][0] = """DefPrm""" Тогда
				ЗаполнитьУмолчанияПараметров(Проц[СчОпциональный], СтрокаПроцедуры.Умолчания);
			КонецЕсли;
		КонецЦикла;
		Счетчик = Счетчик + 1;
	КонецЦикла;

КонецПроцедуры

&НаСервере
Процедура ЗаполнитьУмолчанияПараметров(Блок, ТаблицаПриемник)

	Типы = Новый Соответствие;
	Типы.Вставить("""N""", "Число");
	Типы.Вставить("""S""", "Строка");
	Типы.Вставить("""B""", "Булево");
	Типы.Вставить("""D""", "Дата");
	Типы.Вставить("""L""", "Null");
	Типы.Вставить("""U""", "Неопределено");
	Типы.Вставить("""""", "Нет значения");
	
	ЧислоУмолчаний = Число(Блок[1]);
	
	Для Сч = 2 По ЧислоУмолчаний+1 Цикл
		
		Описание = Блок[Сч];
		Стр = ТаблицаПриемник.Добавить();
		Стр.Тип = Типы[Описание[0]];
		
		Если ПустаяСтрока(Стр.Тип) Тогда
			Стр.Значение = "";
		ИначеЕсли Стр.Тип = "Строка" Тогда
			Стр.Значение = ДесериализоватьСтроку(Описание[1]);
		ИначеЕсли Описание.Количество() = 2 Тогда
			Стр.Значение = Описание[1];
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры


&НаСервере
Функция ЗагрузитьРасшифровкуБайтКода()

	Обработка = РеквизитФормыВЗначение("Объект");
	Макет     = Обработка.ПолучитьМакет("Описание");
	
	ТаблицаРезультат = Новый ТаблицаЗначений;
	ТаблицаРезультат.Колонки.Добавить("Мнемоника");
	ТаблицаРезультат.Колонки.Добавить("Код");
	ТаблицаРезультат.Колонки.Добавить("Название");
	ТаблицаРезультат.Колонки.Добавить("ОписаниеАргумента");
	ТаблицаРезультат.Колонки.Добавить("ЧислоУбираемыхЗначений");
	ТаблицаРезультат.Колонки.Добавить("ЧислоДобавляемыхЗначений");
	
	Для Сч = 2 По Макет.ВысотаТаблицы Цикл
		СтрТаб = ТаблицаРезультат.Добавить();
		СтрТаб.Мнемоника = Макет.Область(Сч,1).Текст;
		Если ПустаяСтрока(СтрТаб.Мнемоника) Тогда
			СтрТаб.Мнемоника = Макет.Область(Сч,3).Текст;
		КонецЕсли;
		СтрТаб.Код = Число(Макет.Область(Сч,2).Текст);
		СтрТаб.Название = Макет.Область(Сч,3).Текст;
		СтрТаб.ОписаниеАргумента = Макет.Область(Сч,4).Текст;
	КонецЦикла;

	Возврат ТаблицаРезультат;
	
КонецФункции // ЗагрузитьРасшифровкуБайтКода()

&НаСервере
Функция ПрочитатьМодуль(Знач Адрес)
	
	ДД = ПолучитьИзВременногоХранилища(Адрес);
	Чтение = Новый ЧтениеТекста(ДД.ОткрытьПотокДляЧтения(),КодировкаТекста.UTF8);
	Текст = Чтение.Прочитать();
	
	Возврат Parse(Текст);

КонецФункции

&НаКлиенте
Процедура ОткрытьФайл(Команда)
	НачатьПомещениеФайла(Новый ОписаниеОповещения("ОбработкаВыбораФайла", ЭтотОбъект));   
	
КонецПроцедуры

&НаКлиенте
Процедура ОбработкаВыбораФайла(Результат, Адрес, ВыбранноеИмя, Контекст) Экспорт

	Если Результат Тогда 
		
		ПозицияГраницыКаталога = СтрНайти(ВыбранноеИмя, "\", НаправлениеПоиска.СКонца, СтрДлина(ВыбранноеИмя)); 
		Каталог = Сред(ВыбранноеИмя, 1, ПозицияГраницыКаталога);
		
		ОткрытьНаСервере(Адрес);
	КонецЕсли;

КонецПроцедуры // ОбработкаВыбораФайла()

&НаКлиентеНаСервереБезКонтекста
Функция ДесериализоватьСтроку(Знач СтрокаИзПотока)

	Возврат Вычислить(СтрЗаменить(СтрокаИзПотока, Символы.ПС, Символы.ПС + "|"));

КонецФункции // ДесериализоватьСтроку()


&НаКлиенте
Процедура ПроцедурыПеременныеФлагиПеременнойНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	
	СтандартнаяОбработка = Ложь;
	П = Новый Структура;
	П.Вставить("ТекущееЗначение", Элементы.ПроцедурыПеременные.ТекущиеДанные.ФлагиПеременной);
	ОткрытьФорму("ВнешняяОбработка.Ассемблер.Форма.ФлагиПеременной", П, Элемент);
	
КонецПроцедуры


&НаКлиенте
Процедура ПеременныеФлагиПеременнойНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	П = Новый Структура;
	П.Вставить("ТекущееЗначение", Элементы.Переменные.ТекущиеДанные.ФлагиПеременной);
	ОткрытьФорму("ВнешняяОбработка.Ассемблер.Форма.ФлагиПеременной", П, Элемент);
КонецПроцедуры


&НаКлиенте
Процедура ПроцедурыТипПроцедурыНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	П = Новый Структура;
	П.Вставить("ТекущееЗначение", Элементы.Процедуры.ТекущиеДанные.ТипПроцедуры);
	ОткрытьФорму("ВнешняяОбработка.Ассемблер.Форма.ФлагиПроцедуры", П, Элемент);
КонецПроцедуры


&НаКлиенте
Процедура ТочкаВхода(Команда)
	ПоказатьВводЧисла(Новый ОписаниеОповещения("ТочкаВходаЗавершение", ЭтаФорма), ТочкаВхода, "Укажите адрес",10,0);
КонецПроцедуры

&НаКлиенте
Процедура ТочкаВходаЗавершение(Число, ДополнительныеПараметры) Экспорт
	
	Если Число = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если Число > Операции.Количество() или Число < 0 Тогда
		Сообщить("Выбранное значение выходит за границы адресов кода");
		Возврат;
	КонецЕсли;
	
	Операции[ТочкаВхода].ЭтоТочкаВхода = 0;
	Операции[Число].ЭтоТочкаВхода = 1;
	ТочкаВхода = Число;
	
КонецПроцедуры

&НаКлиенте
Процедура ПроцедурыПередОкончаниемРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования, Отказ)
	Если НоваяСтрока и ОтменаРедактирования Тогда
		Возврат;
	КонецЕсли;
	
	Если Элементы.Процедуры.ТекущиеДанные.ТипПроцедуры >=32 Тогда
		Возврат;
	КонецЕсли;
	
	ТекЗначениеТВ = Элементы.Процедуры.ТекущиеДанные.ТочкаВхода;
	Если ТекЗначениеТВ < 0 ИЛИ ТекЗначениеТВ > Операции.Количество() Тогда
		Сообщить("Выбранное значение точки входа выходит за границы адресов кода");
		Отказ = Истина;
		Возврат;
	КонецЕсли;
	
	Операции[ЗначениеТочкиВходаПроцедуры].ЭтоТочкаВхода = 0;
	Операции[ТекЗначениеТВ].ЭтоТочкаВхода = 2;
	
КонецПроцедуры

&НаКлиенте
Процедура ПроцедурыПриНачалеРедактирования(Элемент, НоваяСтрока, Копирование)
	ЗначениеТочкиВходаПроцедуры = Элементы.Процедуры.ТекущиеДанные.ТочкаВхода;
КонецПроцедуры

&НаСервере
Функция СправкаПоКомандамНаСервере()
	ОбработкаОбъект = РеквизитФормыВЗначение("Объект");
	Возврат ОбработкаОбъект.ПолучитьМакет("Описание");
КонецФункции

&НаКлиенте
Процедура СправкаПоКомандам(Команда)
	ТД = СправкаПоКомандамНаСервере();
	ТД.Показать("Описание команд");
КонецПроцедуры

&НаКлиенте
Процедура ОперацииПослеУдаления(Элемент)
	ПеренумероватьАдресаКоманд();
КонецПроцедуры

&НаКлиенте
Процедура ПеренумероватьАдресаКоманд()
	ПеренумероватьСтрокиТаблицы(Операции, "Адрес");
КонецПроцедуры

&НаКлиентеНаСервереБезКонтекста
Процедура ПеренумероватьСтрокиТаблицы(Знач Таблица, Знач КолонкаНомер)
	Для Сч = 0 По Таблица.Количество() - 1 Цикл
		Таблица[Сч][КолонкаНомер] = Сч;
	КонецЦикла;
КонецПроцедуры // ПеренумероватьСтрокиТаблицы()


&НаКлиенте
Процедура Перенумеровать(Команда)
	ПеренумероватьАдресаКоманд();
	Точки = Операции.НайтиСтроки(Новый Структура("ЭтоТочкаВхода", 1));
	Для Каждого Точка Из Точки Цикл
		Точка.ЭтоТочкаВхода = 0;
	КонецЦикла;
	
	Точки = Операции.НайтиСтроки(Новый Структура("ЭтоТочкаВхода", 2));
	Для Каждого Точка Из Точки Цикл
		Точка.ЭтоТочкаВхода = 0;
	КонецЦикла;
	
	Для Каждого Проц Из Процедуры Цикл
		Если Проц.ТипПроцедуры < 32 и Проц.ТочкаВхода < Операции.Количество() и Проц.ТочкаВхода >= 0 Тогда
			Операции[Проц.ТочкаВхода].ЭтоТочкаВхода = 2;
		КонецЕсли;
	КонецЦикла;
	
	Операции[ТочкаВхода].ЭтоТочкаВхода = 1;
	
КонецПроцедуры

&НаСервере
Функция СохранитьНаСервере()

	БОМ = Новый БуферДвоичныхДанных(3);
	БОМ[0] = 239;
	БОМ[1] = 187;
	БОМ[2] = 191;
	Поток = Новый ПотокВПамяти(1024);
	Поток.Записать(БОМ,0, 3);
	СериализоватьМодуль(Поток);
	ДД = Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
	Возврат ПоместитьВоВременноеХранилище(ДД);

КонецФункции // СохранитьНаСервере()

#Область ФункцииЗаписиПотока

Процедура СериализоватьМодуль(Знач Поток)
	
	Запись = Новый ЗаписьТекста(Поток, КодировкаТекста.UTF8);
	КонтекстЗаписи = Новый Структура;
	КонтекстЗаписи.Вставить("Запись", Запись);
	КонтекстЗаписи.Вставить("Списки", Новый Массив);
	
	ЗаписатьМодуль(КонтекстЗаписи);
	Запись.Закрыть();
	
КонецПроцедуры

Функция СписокОткрыт(Знач КонтекстЗаписи)
	М = КонтекстЗаписи.Списки;
	Если М.Количество() Тогда
		Возврат М[М.ВГраница()];
	КонецЕсли;
	Возврат Ложь;
КонецФункции

Процедура ОткрытьСписок(Знач КонтекстЗаписи)
	М = КонтекстЗаписи.Списки;
	Если М.Количество() Тогда
		М[М.ВГраница()] = Истина;
	КонецЕсли;
КонецПроцедуры

Процедура ЗаписатьНачалоОбъекта(Знач КонтекстЗаписи, Знач СНовойСтроки = Истина)
	
	Если СписокОткрыт(КонтекстЗаписи) Тогда
		ЗаписатьРазделитель(КонтекстЗаписи);
	Иначе
		ОткрытьСписок(КонтекстЗаписи);
	КонецЕсли;
	
	Если СНовойСтроки Тогда
		ЗаписатьРазделительСтрок(КонтекстЗаписи);
	КонецЕсли;
	
	КонтекстЗаписи.Запись.Записать("{");
	КонтекстЗаписи.Списки.Добавить(Ложь);

КонецПроцедуры

Процедура ЗаписатьКонецОбъекта(Знач КонтекстЗаписи)
	
	КонтекстЗаписи.Запись.Записать("}");
	М = КонтекстЗаписи.Списки;
	М.Удалить(М.ВГраница());

КонецПроцедуры

Процедура ЗаписатьРазделитель(Знач КонтекстЗаписи)
	
	КонтекстЗаписи.Запись.Записать(",");

КонецПроцедуры

Процедура ЗаписатьРазделительСтрок(Знач КонтекстЗаписи)
	
	КонтекстЗаписи.Запись.Записать(Символы.ПС);

КонецПроцедуры

Процедура ЗаписатьЗначение(Знач КонтекстЗаписи, Знач Значение)

	Если СписокОткрыт(КонтекстЗаписи) Тогда
		ЗаписатьРазделитель(КонтекстЗаписи);
	Иначе
		ОткрытьСписок(КонтекстЗаписи);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Число") Тогда
		КонтекстЗаписи.Запись.Записать(Формат(Значение,"ЧН=0; ЧГ=0"));
	ИначеЕсли ТипЗнч(Значение) = Тип("Строка") Тогда
		КонтекстЗаписи.Запись.Записать(СтрШаблон("""%1""", СтрЗаменить(Значение, """", """""")));
	ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда
		КонтекстЗаписи.Запись.Записать(Формат(Значение,"ДФ=yyyyMMddHHmmss; ДП="));
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура ЗаписатьМодуль(Знач КонтекстЗаписи)

	ЗаписатьНачалоОбъекта(КонтекстЗаписи, Ложь);
	ЗаписатьЗначение(КонтекстЗаписи, 1);
	ЗаписатьКоманды(КонтекстЗаписи);
	ЗаписатьКонстанты(КонтекстЗаписи);
	ЗаписатьПеременные(КонтекстЗаписи, Переменные);
	ЗаписатьПроцедуры(КонтекстЗаписи);
	ЗаписатьРазделительСтрок(КонтекстЗаписи);
	ЗаписатьКонецОбъекта(КонтекстЗаписи);

КонецПроцедуры // ЗаписатьМодуль()


&НаСервере
Процедура ЗаписатьКоманды(Знач КонтекстЗаписи)

	ЗаписатьНачалоОбъекта(КонтекстЗаписи);
	ЗаписатьЗначение(КонтекстЗаписи, "Cmd");
	ЗаписатьЗначение(КонтекстЗаписи, Операции.Количество());
	ЗаписатьЗначение(КонтекстЗаписи, ТочкаВхода);
	
	Для Каждого Оп Из Операции Цикл
		ЗаписатьНачалоОбъекта(КонтекстЗаписи);
		ЗаписатьЗначение(КонтекстЗаписи, Оп.КодОперации);
		ЗаписатьЗначение(КонтекстЗаписи, Оп.Аргумент);
		ЗаписатьКонецОбъекта(КонтекстЗаписи);
	КонецЦикла;
	ЗаписатьРазделительСтрок(КонтекстЗаписи);
	ЗаписатьКонецОбъекта(КонтекстЗаписи);

КонецПроцедуры // ЗаписатьКоманды()

&НаСервере
Процедура ЗаписатьКонстанты(КонтекстЗаписи)

	Если Не Константы.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьНачалоОбъекта(КонтекстЗаписи);
	ЗаписатьЗначение(КонтекстЗаписи, "Const");
	ЗаписатьЗначение(КонтекстЗаписи, Константы.Количество());
	
	Типы = Новый Соответствие;
	Типы.Вставить("Строка","S");
	Типы.Вставить("Число","N");
	Типы.Вставить("Булево","B");
	Типы.Вставить("Дата","D");
	Типы.Вставить("Null","L");
	Типы.Вставить("Неопределено","U");
	
	Для Каждого Конст Из ЭтаФорма.Константы Цикл
		ЗаписатьНачалоОбъекта(КонтекстЗаписи);
		ЗаписатьЗначение(КонтекстЗаписи, Типы[Конст.ТипКонстанты]);
		Если Конст.ТипКонстанты = "Строка" Тогда
			ЗаписатьЗначение(КонтекстЗаписи, Конст.Значение);
		ИначеЕсли Конст.ТипКонстанты = "Число" или Конст.ТипКонстанты = "Булево" Тогда
			ЗаписатьЗначение(КонтекстЗаписи, Число(Конст.Значение));
		ИначеЕсли Конст.ТипКонстанты = "Дата" Тогда
			ЗначениеДаты = Вычислить("'" + Конст.Значение + "'");
			ЗаписатьЗначение(КонтекстЗаписи, ЗначениеДаты);
		КонецЕсли;
		ЗаписатьКонецОбъекта(КонтекстЗаписи);
	КонецЦикла;
	ЗаписатьРазделительСтрок(КонтекстЗаписи);
	ЗаписатьКонецОбъекта(КонтекстЗаписи);

КонецПроцедуры // ЗаписатьКонстанты()

&НаСервере
Процедура ЗаписатьПеременные(Знач КонтекстЗаписи, Знач ТаблицаПеременных)

	Если Не ТаблицаПеременных.Количество() Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписатьНачалоОбъекта(КонтекстЗаписи);
	ЗаписатьЗначение(КонтекстЗаписи, "Var");
	ЗаписатьЗначение(КонтекстЗаписи, ТаблицаПеременных.Количество());
	
	Для Каждого Переменная Из ТаблицаПеременных Цикл
		ЗаписатьНачалоОбъекта(КонтекстЗаписи);
		ЗаписатьЗначение(КонтекстЗаписи, Переменная.ИмяПеременной);
		ЗаписатьЗначение(КонтекстЗаписи, Переменная.ФлагиПеременной);
		ЗаписатьЗначение(КонтекстЗаписи, -1);
		ЗаписатьКонецОбъекта(КонтекстЗаписи);
	КонецЦикла;
	ЗаписатьРазделительСтрок(КонтекстЗаписи);
	ЗаписатьКонецОбъекта(КонтекстЗаписи);

КонецПроцедуры // ЗаписатьПеременные()

&НаСервере
Процедура ЗаписатьПроцедуры(Знач КонтекстЗаписи)

	ЗаписатьНачалоОбъекта(КонтекстЗаписи);
	ЗаписатьЗначение(КонтекстЗаписи, "Proc");
	ЗаписатьЗначение(КонтекстЗаписи, Процедуры.Количество());
	
	Для Каждого Проц Из Процедуры Цикл
		
		ЗаписатьНачалоОбъекта(КонтекстЗаписи);
		ЗаписатьЗначение(КонтекстЗаписи, Проц.ИмяПроцедуры);
		ЗаписатьЗначение(КонтекстЗаписи, Проц.ТипПроцедуры);
		ЗаписатьЗначение(КонтекстЗаписи, Проц.ЧислоАргументов);
		ЗаписатьЗначение(КонтекстЗаписи, Проц.ТочкаВхода);
		
		ЗаписатьПеременные(КонтекстЗаписи, Проц.Переменные);
		Если Проц.ТипПроцедуры < 32 Тогда
			Если Проц.Умолчания.Количество() = Проц.ЧислоАргументов Тогда
				ЗаписатьУмолчанияПараметров(КонтекстЗаписи, Проц.Умолчания);
			Иначе
				ВызватьИсключение СтрШаблон("Для процедуры %1 число параметров по умолчанию не совпадает с числом аргументов
				|Параметры не имеющие умолчаний все равно должны отражаться в таблице умолчаний с типом 'Нет значения'", Проц.ИмяПроцедуры);
			КонецЕсли;
		КонецЕсли;
		
		ЗаписатьРазделительСтрок(КонтекстЗаписи);
		ЗаписатьКонецОбъекта(КонтекстЗаписи);
		
	КонецЦикла;
	
	ЗаписатьРазделительСтрок(КонтекстЗаписи);
	ЗаписатьКонецОбъекта(КонтекстЗаписи);
	
КонецПроцедуры // ЗаписатьПроцедуры()

&НаСервере
Процедура ЗаписатьУмолчанияПараметров(Знач КонтекстЗаписи, Знач УмолчанияПараметров)
	
	ЗаписатьНачалоОбъекта(КонтекстЗаписи);
	ЗаписатьЗначение(КонтекстЗаписи, "DefPrm");
	ЗаписатьЗначение(КонтекстЗаписи, УмолчанияПараметров.Количество());
	
	Типы = Новый Соответствие;
	Типы.Вставить("Строка","S");
	Типы.Вставить("Число","N");
	Типы.Вставить("Булево","B");
	Типы.Вставить("Дата","D");
	Типы.Вставить("Null","L");
	Типы.Вставить("Неопределено","U");
	Типы.Вставить("Нет значения","");
	
	Для Каждого Умолчание Из УмолчанияПараметров Цикл
		ЗаписатьНачалоОбъекта(КонтекстЗаписи);
		
		ЗаписатьЗначение(КонтекстЗаписи, Типы[Умолчание.Тип]);
		Если Умолчание.Тип = "Строка" Тогда
			ЗаписатьЗначение(КонтекстЗаписи, Умолчание.Значение);
		ИначеЕсли Умолчание.Тип = "Число" или Умолчание.Тип = "Булево" Тогда
			ЗаписатьЗначение(КонтекстЗаписи, Число(Умолчание.Значение));
		ИначеЕсли Умолчание.Тип = "Дата" Тогда
			ЗначениеДаты = Вычислить("'" + Умолчание.Значение + "'");
			ЗаписатьЗначение(КонтекстЗаписи, ЗначениеДаты);
		КонецЕсли;		
		ЗаписатьКонецОбъекта(КонтекстЗаписи);
	КонецЦикла;
	ЗаписатьРазделительСтрок(КонтекстЗаписи);
	ЗаписатьКонецОбъекта(КонтекстЗаписи);

КонецПроцедуры // ЗаписатьУмолчанияПараметров()


#КонецОбласти

&НаКлиенте
Процедура Сохранить(Команда)
	Адрес = СохранитьНаСервере();
	ПолучитьФайл(Адрес, "image"); 
КонецПроцедуры


&НаКлиенте
Процедура ОперацииИмяОперацииОбработкаВыбора(Элемент, ВыбранноеЗначение, СтандартнаяОбработка)
	Элт = РасшифровкаОпераций.НайтиСтроки(Новый Структура("Мнемоника", ВыбранноеЗначение))[0];
	ТД = Элементы.Операции.ТекущиеДанные;
	ТД.КодОперации = Элт.Код;
	ТД.Описание = Элт.Название + Символы.ПС + Элт.ОписаниеАргумента;
КонецПроцедуры


&НаКлиенте
Процедура ОперацииПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	Если Не ОтменаРедактирования Тогда
		ПеренумероватьАдресаКоманд();
	КонецЕсли;
КонецПроцедуры


&НаКлиенте
Процедура КонстантыПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	Если Не ОтменаРедактирования Тогда
		ПеренумероватьСтрокиТаблицы(Константы, "Номер");
	КонецЕсли;
КонецПроцедуры

&НаКлиенте
Процедура ПеременныеПриОкончанииРедактирования(Элемент, НоваяСтрока, ОтменаРедактирования)
	Если Не ОтменаРедактирования Тогда
		ПеренумероватьСтрокиТаблицы(Переменные, "Номер");
	КонецЕсли;
КонецПроцедуры



&НаКлиенте
Процедура КонстантыЗначениеНачалоВыбора(Элемент, ДанныеВыбора, СтандартнаяОбработка)
	СтандартнаяОбработка = Ложь;
	П = Новый Структура("Текст", Элементы.Константы.ТекущиеДанные.Значение);
	ОткрытьФорму("ВнешняяОбработка.Ассемблер.Форма.ВводТекста", П, Элемент);
КонецПроцедуры


&НаСервере
Процедура СобратьНаСервере()
	
	Если ПустаяСтрока(РабочийКаталог) Тогда
		РабочийКаталог = ПолучитьИмяВременногоФайла();
		СоздатьКаталог(РабочийКаталог);
		
		ДДОбработки = РеквизитФормыВЗначение("Объект").ПолучитьМакет("МакетОбработки");
		ДДОбработки.Записать(РабочийКаталог + ПолучитьРазделительПути() + "work.epf");
		
		Код = Неопределено;
		ЗапуститьПриложение("v8unpack -P work.epf decompiled", РабочийКаталог, Истина, Код);
		Если Код <> 0 Тогда
			Сообщить("Не удалось декомпилировать обработку. Возможно не установлен v8unpack в PATH");
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	ФайлОбраза = РабочийКаталог 
		+ ПолучитьРазделительПути() 
		+ "decompiled/4070aaa7-bb18-4293-9cd6-4112a9abe2ca.0/image"; // нормальный разделитель нормально работает
		
	ФП = ФайловыеПотоки.ОткрытьДляЗаписи(ФайлОбраза);
	СериализоватьМодуль(ФП);
	ФП.Закрыть();
	
	Код = Неопределено;
	ЗапуститьПриложение("v8unpack -B decompiled work.epf", РабочийКаталог, Истина, Код);
	Если Код <> 0 Тогда
		Сообщить("Не удалось декомпилировать обработку. Возможно не установлен v8unpack в PATH");
		Возврат;
	КонецЕсли;
	
КонецПроцедуры

&НаСервере
Процедура ЗапуститьНаСервере()
	
	ВнешниеОбработки.Создать(РабочийКаталог + ПолучитьРазделительПути() + "work.epf");

КонецПроцедуры // ЗапуститьНаСервере()


&НаКлиенте
Процедура Запустить(Команда)
	СобратьНаСервере();
	ЭтаФорма.Активизировать(); // окно декомпилятора прыгает
	ЗапуститьНаСервере();
КонецПроцедуры

//&НаКлиенте
//Асинх Процедура СохранитьВJson(Команда)
//	Адрес = СохранитьВJsonНаСервере();
//	Ждать ПолучитьФайлССервераАсинх(Адрес, "module.json", Новый ПараметрыДиалогаПолученияФайлов(, Ложь));
//КонецПроцедуры


//&НаСервере
//Функция СохранитьВJsonНаСервере()
//	Обработка = РеквизитФормыВЗначение("Объект");
//	Модуль = Обработка.Модуль(
//		РеквизитФормыВЗначение("Операции"),
//		РеквизитФормыВЗначение("Константы"),
//		РеквизитФормыВЗначение("Процедуры"),
//		РеквизитФормыВЗначение("Переменные"),
//		ТочкаВхода);
//	
//	ЦелевойПоток = Новый ПотокВПамяти();
//	Запись = Новый ЗаписьJSON();
//	Запись.ОткрытьПоток(ЦелевойПоток);
//	
//	Обработка.СохранитьВJson(Запись, Модуль);
//	Запись.Закрыть();
//	
//	Возврат ПоместитьВоВременноеХранилище(ЦелевойПоток.ЗакрытьИПолучитьДвоичныеДанные());
//	
//КонецФункции

&НаКлиенте
Процедура Декомпиляция(Команда)

	Если Не ЗначениеЗаполнено(Каталог) Тогда
		
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Не открыт файл для компиляции";
		Сообщение.Сообщить();
		
		Возврат;
	
	КонецЕсли; 
	
	ДекомпиляцияНаСервере(); 
	
	Если ТипМодуля = 0 Тогда //Общий модуль
		НовоеИмяФайла = Каталог + "Module.bsl";	
	ИначеЕсли ТипМодуля = 1 Тогда //Модуль обработки
		НовоеИмяФайла = Каталог + "ObjectModule.bsl";	
	КонецЕсли; 
	
	Запись = Новый ЗаписьТекста(НовоеИмяФайла, КодировкаТекста.UTF8);
	Запись.Записать(ТекстМодуля.ПолучитьТекст());  
	Запись.Закрыть();
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = СтрШаблон("Декомпиляция успешно завершена. Открытый модуль сохранен в %1", НовоеИмяФайла);;
	Сообщение.Сообщить();
	
КонецПроцедуры 

&НаСервере
Процедура ДекомпиляцияНаСервере()  
	
	ТекстМодуля.Очистить();
	
	ПриоритетыОпераций = Новый Соответствие;
	ПриоритетыОпераций.Вставить(23, 0);    //Minus
	ПриоритетыОпераций.Вставить(24, 2);    //Операция +
	ПриоритетыОпераций.Вставить(25, 2);    //Операция -
	ПриоритетыОпераций.Вставить(26, 1);    //Операция *
	ПриоритетыОпераций.Вставить(27, 1);    //Операция /
	ПриоритетыОпераций.Вставить(28, 1);    //Операция %
	ПриоритетыОпераций.Вставить(29, 3);    //Операция Не
	ПриоритетыОпераций.Вставить(30, 5);    //И
	ПриоритетыОпераций.Вставить(31, 6);    //ИЛИ
	ПриоритетыОпераций.Вставить(33, 4);    //Операция = (сравнение)
	ПриоритетыОпераций.Вставить(34, 4);    //Операция <>
	ПриоритетыОпераций.Вставить(35, 4);    //Операция >
	ПриоритетыОпераций.Вставить(36, 4);    //Операция <
	ПриоритетыОпераций.Вставить(37, 4);    //Операция >=
	ПриоритетыОпераций.Вставить(38, 4);    //Операция <=

	
	ЛокальныеМетоды = Новый Массив;
	
	Для ИндПроцедуры = 0 По Процедуры.Количество()-1 Цикл 
		Если Процедуры[ИндПроцедуры].ТипПроцедуры >= 32 Тогда
			//это глобальные
			Продолжить;
		КонецЕсли;
		
		ЛокальныеМетоды.Добавить(ИндПроцедуры); 
		МаксИндексПроцедуры = ИндПроцедуры;
	КонецЦикла;
	
	
	//выводим процедуры детально
	
	Для ИндЛокальногоМетода = 0 По ЛокальныеМетоды.Количество() - 1 Цикл
		
		ИндПроцедуры = ЛокальныеМетоды[ИндЛокальногоМетода];
		  
		//ПЕРЕМЕННЫЕ  
		МассивСтрокПроцедуры = Новый Массив;
		
		СтрПроцедура = Процедуры[ИндПроцедуры];
		ПерваяОперация = СтрПроцедура.ТочкаВхода;
		ЭтоФункция = Ложь; 
		ПоследняяОперация = 0;
		
		ИндОперации = ПерваяОперация;
		//найдем окончание метода
		//и по ходу вычислим функция это или процедура
		Пока Истина Цикл
			
			ТекущийКодОперации = Операции[ИндОперации].КодОперации;
			
			Если ТекущийКодОперации = 17 Тогда //Ret
				ЭтоФункция = Истина;
			КонецЕсли;
			Если ТекущийКодОперации = 22 Тогда //КонецПроцедуры/КонецФункции 
				ПоследняяОперация = ИндОперации;
				Прервать;	
			КонецЕсли; 
			
			ИндОперации = ИндОперации + 1;	
			
		КонецЦикла; 
					
		ИмяМетода = СтрПроцедура.ИмяПроцедуры;
		Экспортная = (СтрПроцедура.ТипПроцедуры > 1);
		МассивАргументов = Новый Массив;
		МассивЛокальныхПеременных = Новый Массив;
				
		//вычислим аргументы
		Для ИндПерем = 0 По СтрПроцедура.ЧислоАргументов-1 Цикл
			
			СтрокаАгрумента = СтрПроцедура.Переменные[ИндПерем].ИмяПеременной;
			ФлагиПеременной = СтрПроцедура.Переменные[ИндПерем].ФлагиПеременной;
			УмолчаниеТип = СтрПроцедура.Умолчания[ИндПерем].Тип;
			УмолчаниеЗначение = СтрПроцедура.Умолчания[ИндПерем].Значение;
			
			//Типы.Вставить("Строка","S");
			//Типы.Вставить("Число","N");
			//Типы.Вставить("Булево","B");
			//Типы.Вставить("Дата","D");
			//Типы.Вставить("Null","L");
			//Типы.Вставить("Неопределено","U");
			//Типы.Вставить("Нет значения","");
	
			Если УмолчаниеТип = "Строка" Тогда
				СтрокаАгрумента = СтрокаАгрумента + СтрШаблон(" = ""%1""",УмолчаниеЗначение);	
			ИначеЕсли УмолчаниеТип = "Число" Тогда
				СтрокаАгрумента = СтрокаАгрумента + СтрШаблон(" = %1",УмолчаниеЗначение);	
			ИначеЕсли УмолчаниеТип = "Булево" Тогда
				Если УмолчаниеЗначение = "1" Тогда
					СтрокаАгрумента = СтрокаАгрумента + " = ИСТИНА";	
				Иначе
					СтрокаАгрумента = СтрокаАгрумента + " = ЛОЖЬ";	
				КонецЕсли;
			ИначеЕсли УмолчаниеТип = "Дата" Тогда
				СтрокаАгрумента = СтрокаАгрумента + СтрШаблон(" = '%1'",УмолчаниеЗначение);	
			ИначеЕсли УмолчаниеТип = "Null" Тогда
				СтрокаАгрумента = СтрокаАгрумента + " = NULL";	
			ИначеЕсли УмолчаниеТип = "Неопределено" Тогда
				СтрокаАгрумента = СтрокаАгрумента + " = Неопределено";	
			ИначеЕсли УмолчаниеТип = "Нет значения" Тогда
				//ничего не присваиваем
			КонецЕсли;        
			
			Если ФлагиПеременной = 13 Тогда
			
				СтрокаАгрумента = "Знач " + СтрокаАгрумента;	
			
			КонецЕсли; 
			
			МассивАргументов.Добавить(СтрокаАгрумента);
			
		КонецЦикла;
		
		
		Для ИндПерем = СтрПроцедура.ЧислоАргументов По СтрПроцедура.Переменные.Количество()-1 Цикл
			
			ИмяПеременной = СтрПроцедура.Переменные[ИндПерем].ИмяПеременной;
			
			Если Лев(ИмяПеременной,1) <> "0" Тогда
			
				МассивЛокальныхПеременных.Добавить(СтрПроцедура.Переменные[ИндПерем].ИмяПеременной);
			
			КонецЕсли; 
		
		КонецЦикла;
		
		//Сформируем шапку и окончание функции/процедуры 
		
		ИмяМетодаСАргументами = ИмяМетода + "("; 
		Счетчик = 0;
		Для каждого СтрокаАгрумента Из МассивАргументов Цикл
			        
			Если Счетчик = 0 Тогда
				ИмяМетодаСАргументами = ИмяМетодаСАргументами + СтрокаАгрумента;	
			Иначе 
				ИмяМетодаСАргументами = ИмяМетодаСАргументами + ", " + СтрокаАгрумента;	
			КонецЕсли;
			
			Счетчик = Счетчик + 1;
			
		КонецЦикла;
		
		ИмяМетодаСАргументами = ИмяМетодаСАргументами + ")";   
		
		ШапкаМетода = ?(ЭтоФункция, "Функция ", "Процедура ") + ИмяМетодаСАргументами + ?(Экспортная, " Экспорт", "") + Символы.ПС;
		ПодвалМетода = Символы.ПС + ?(ЭтоФункция, "КонецФункции", "КонецПроцедуры") + " // " +ИмяМетодаСАргументами + Символы.ПС;
		
		МассивСтрокПроцедуры.Добавить(ШапкаМетода); 
		
		Для каждого ЛокПерем Из МассивЛокальныхПеременных Цикл
		
			МассивСтрокПроцедуры.Добавить(СтрШаблон("Перем %1;", ЛокПерем));
		
		КонецЦикла;
		
		МассивСтрокПроцедуры.Добавить(Символы.ПС); 
		
		//Обработка тела метода			
		ТекстТелаМетода = ПолучитьТекстТелаМетода(ПерваяОперация, ПоследняяОперация, ИндПроцедуры, ЭтоФункция); 
			
		МассивСтрокПроцедуры.Добавить(ТекстТелаМетода);
				
		МассивСтрокПроцедуры.Добавить(ПодвалМетода);
				
		ПроцедураСтрокой = СтрСоединить(МассивСтрокПроцедуры, Символы.ПС);
		
		ТекстМодуля.ДобавитьСтроку(ПроцедураСтрокой);
		
	КонецЦикла;

КонецПроцедуры

Функция ПолучитьТекстТелаМетода(ПерваяОперация, ПоследняяОперация, ИндПроцедуры, ЭтоФункция)
	
	ТекстТелаМетода = ""; 
	
	Стек = Новый Массив(255);
	ВершинаСтека = -1;
	ПоследнийИндексОпераций = Операции.Количество() - 1; 
	СоответствиеМетокПерехода = Новый Соответствие;
	
	Для каждого Стр Из Процедуры[ИндПроцедуры].МеткиПерехода Цикл
		
		СоответствиеМетокПерехода.Вставить(Стр.НомерОперации, Стр.ИмяМетки);	
		
	КонецЦикла;
	
	СоответствиеБлоков = Новый Соответствие;
	
	
	ТЗПопыток = Новый ТаблицаЗначений;
	ТЗПопыток.Колонки.Добавить("Уровень");
	ТЗПопыток.Колонки.Добавить("Начало");
	ТЗПопыток.Колонки.Добавить("Конец");
	ТЗПопыток.Колонки.Добавить("Исключение"); 
	
	Уровень = 0;
	
	Для ИндОперации = ПерваяОперация По ПоследняяОперация Цикл
		
		КодОперации = Операции[ИндОперации].КодОперации;
		
		Если КодОперации = 44 Тогда //Попытка
			НовСтрока = ТЗПопыток.Добавить();
			НовСтрока.Начало = ИндОперации;
			
		ИначеЕсли КодОперации = 45 Тогда //Возврат/Исключение
			//пока ничего
			
		ИначеЕсли КодОперации = 46 Тогда //КонецПопытки
			
			МаксИндексТаблицы = ТЗПопыток.Количество()-1;
			
			Пока МаксИндексТаблицы > -1 Цикл
				Если ТЗПопыток[МаксИндексТаблицы].Конец = Неопределено Тогда
					ТЗПопыток[МаксИндексТаблицы].Конец = ИндОперации; 
					Прервать;
				Иначе 
					МаксИндексТаблицы = МаксИндексТаблицы - 1;	
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;  
	
	
	Для ИндексПопытки = 0 По ТЗПопыток.Количество() - 1 Цикл
		
		ТекущийУровень = 0;
		ПервыйПодходящий = Неопределено;
		ПоследнийПодходящий = Неопределено;
		
		СтрокаПопытки = ТЗПопыток[ИндексПопытки];
		
		
		Для ИндОперации = СтрокаПопытки.Начало По СтрокаПопытки.Конец Цикл
			
			КодОперации = Операции[ИндОперации].КодОперации;
			Аргумент = Операции[ИндОперации].Аргумент; 
			
			Если КодОперации <> 45 или
				Аргумент <> 1 или
				Операции[ИндОперации-1].КодОперации = 17 Тогда //возврат из функции 100%
				//анализируем только этот код операции
				//только с аргументом 1 есть исключения
				Продолжить;
				
			КонецЕсли; 
			
			ВхождениеВДругиеПопытки = Ложь;
			
			Для ЧужойИндексПопытки = 0 По ТЗПопыток.Количество() - 1 Цикл  
				
				Если ИндексПопытки = ЧужойИндексПопытки Тогда
					Продолжить;	
				КонецЕсли; 
				
				СтрокаЧужойПопытки = ТЗПопыток[ЧужойИндексПопытки];
				
				Если СтрокаПопытки.Начало >= СтрокаЧужойПопытки.Начало и
					СтрокаПопытки.Начало <= СтрокаЧужойПопытки.Конец Тогда
					
					//родительские попытки тоже пропускаем
					//Но сначала берем от туда уровень
					
					Если СтрокаПопытки.Начало >= СтрокаЧужойПопытки.Исключение Тогда
						//Значит этот блок в родительском исключении
						//Уровень как у родителя
						ТекущийУровень = СтрокаЧужойПопытки.Уровень;
					Иначе 
						ТекущийУровень = СтрокаЧужойПопытки.Уровень+1;
						
					КонецЕсли; 
					
					Продолжить;	
					
				КонецЕсли; 
				
				Если ИндОперации >= СтрокаЧужойПопытки.Начало и
					ИндОперации <= СтрокаЧужойПопытки.Конец Тогда
					
					//Исключаем операции из других попыток
					ВхождениеВДругиеПопытки = Истина;
					Прервать;
					
				КонецЕсли; 
				
			КонецЦикла; 
			
			Если ВхождениеВДругиеПопытки Тогда
				
				Продолжить;
				
			КонецЕсли;
			
			Если ПервыйПодходящий = Неопределено Тогда
				
				ПервыйПодходящий = ИндОперации;	
				
			КонецЕсли;
			
			ПоследнийПодходящий = ИндОперации;
			
		КонецЦикла;
		
		Если ТекущийУровень = 0 Тогда
			СтрокаПопытки.Исключение = ПоследнийПодходящий;
		ИначеЕсли ТекущийУровень = 1 Тогда
			СтрокаПопытки.Исключение = ПервыйПодходящий;
		Иначе
			СтрокаПопытки.Исключение = ПервыйПодходящий;
		КонецЕсли; 
		
		СтрокаПопытки.Уровень = ТекущийУровень;
		
	КонецЦикла;	
	
	Исключения = ТЗПопыток.ВыгрузитьКолонку("Исключение");	
	
	Для ИндОперации = ПерваяОперация По ПоследняяОперация Цикл
		ОбработатьОперацию(ИндОперации, ИндПроцедуры, ТекстТелаМетода, Стек, ВершинаСтека, ПоследнийИндексОпераций, СоответствиеМетокПерехода, СоответствиеБлоков, Исключения, Ложь, ЭтоФункция);
	КонецЦикла;
	
	Возврат ТекстТелаМетода;
	
КонецФункции // ПолучитьТекстТелаМетода()   

Процедура ОбработатьОперацию(ИндОперации, ИндПроцедуры, ТекстТелаМетода, Стек, ВершинаСтека, ПоследнийИндексОпераций, СоответствиеМетокПерехода, СоответствиеБлоков, Исключения, ИгнорироватьКонецСтроки, ЭтоФункция)
	
	КодОперации = Операции[ИндОперации].КодОперации;
	
	Если КодОперации = 0 Тогда
		//Нет операции
	ИначеЕсли КодОперации = 1 Тогда 
		//Начало строки кода  
		Если ВершинаСтека > -1 Тогда
			
			Если Операции[ИндОперации+1].КодОперации = 40 Тогда
				//Проверка на цикл "Пока Условие Цикл"
				
				ИндексПерехода = Операции[ИндОперации+1].Аргумент; 
				ИндПереходаСледОперации = Операции[ИндексПерехода-1].Аргумент;   
				
				Если ИндПереходаСледОперации < ИндОперации Тогда 
					//это цикл "Пока Условие Цикл"
					//циклы переходят назад
					
					КонецБлока = СоответствиеБлоков.Получить(ИндексПерехода); 
					
					Если КонецБлока = Неопределено Тогда
						
						//КонецЦикла "Пока Истина Цикл"
						//может ссылаться на "КонецЕсли", если он находится внутри секции "Если"
						//но наоборот быть не может
						СоответствиеБлоков.Вставить(ИндексПерехода, "КонецЦикла;");
						
					Иначе
						
						СоответствиеБлоков.Вставить(ИндексПерехода, "КонецЦикла;" + Символы.ПС + Символы.ПС + КонецБлока);
						
					КонецЕсли; 
					
					КусокКода = "Пока " + Стек[ВершинаСтека] + " Цикл";
					
					ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);
					
				КонецЕсли;
				
			КонецЕсли; 
			
			
			Для ИндВершины = 0 По ВершинаСтека Цикл
				
				Если ЗначениеЗаполнено(ТекстТелаМетода) Тогда
					
					ТекстТелаМетода = ТекстТелаМетода + Символы.ПС + Символы.ПС + Стек[ИндВершины];
					
				Иначе
					
					ТекстТелаМетода = Стек[ИндВершины];
					
				КонецЕсли; 
				
			КонецЦикла;   
			
			ВершинаСтека = -1;
			
		КонецЕсли; 
	ИначеЕсли КодОперации = 2 Тогда 
		//Загрузить в стек глобальную переменную
		
		ИндПеременной = Операции[ИндОперации].Аргумент;
		КусокКода = Переменные[ИндПеременной].ИмяПеременной; 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода);
		
	ИначеЕсли КодОперации = 3 Тогда 
		//Загрузить в стек локальную переменную
		ИндПеременной = Операции[ИндОперации].Аргумент;
		КусокКода = Процедуры[ИндПроцедуры].Переменные[ИндПеременной].ИмяПеременной; 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода);
		
	ИначеЕсли КодОперации = 4 Тогда 
		//Загрузить в стек константное значение
		ИндКонстанты= Операции[ИндОперации].Аргумент;
		КусокКода = ПолучитьПредставлениеПоТипу(Константы[ИндКонстанты].ТипКонстанты, Константы[ИндКонстанты].Значение); 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода);
		
	ИначеЕсли КодОперации = 5 Тогда 
		//Загрузить на стек результат последней функции/метода  
		
		ЗафиксироватьКонецБлока(СоответствиеБлоков, ИндОперации, ТекстТелаМетода);
		ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, ИндОперации, ТекстТелаМетода);
		
		ИндОперации = ИндОперации +1;
		
	ИначеЕсли КодОперации = 6 Тогда 
		//Загрузить на стек Ложь 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "Ложь");
		
	ИначеЕсли КодОперации = 7 Тогда 
		//Загрузить на стек Истина
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "Истина");
		
	ИначеЕсли КодОперации = 8 Тогда 
		//Загрузить на стек Неопределено
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "Неопределено");
		
	ИначеЕсли КодОперации = 9 Тогда 
		//Загрузить на стек Null
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "NULL");			
		
	ИначеЕсли КодОперации = 10 Тогда 
		//Загрузить на стек пустое значение
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "");			
		
	ИначеЕсли КодОперации = 11 Тогда 
		//Unknown
		ВызватьИсключение СтрШаблон("Не предусмотрен КодОперации=%1",КодОперации);
		
	ИначеЕсли КодОперации = 12 Тогда  
		//Получение свойства .<Имя Свойства>
		
		ИндКонстанты = Операции[ИндОперации].Аргумент;
		
		КусокКода = Стек[ВершинаСтека] + "." + Константы[ИндКонстанты].Значение; 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);			
		
	ИначеЕсли КодОперации = 13 Тогда 
		//Получение элемента массива []
		КусокКода = Стек[ВершинаСтека-1] + "[" + Стек[ВершинаСтека] + "]"; 
		ДобавитьКонецСтроки(КусокКода, ИндОперации, ИгнорироватьКонецСтроки);  
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 14 Тогда 
		//Получить из коллекции выборку
		ВызватьИсключение СтрШаблон("Не предусмотрен КодОперации=%1.",КодОперации);  
		//Этот код встречается в цикле "Для каждого Эл Из М Цикл"  
		//но мы не обрабатываем эти коды, т.к.они не отображаются в коде 1С
		
	ИначеЕсли КодОперации = 15 Тогда 
		//Получить из коллекции выборку
		ВызватьИсключение СтрШаблон("Не предусмотрен КодОперации=%1.",КодОперации);  
		//Этот код встречается в цикле "Для каждого Эл Из М Цикл"  
		//но мы не обрабатываем эти коды, т.к.они не отображаются в коде 1С
		
	ИначеЕсли КодОперации = 16 Тогда 
		//Операция = (присвоение)
		КусокКода = Стек[ВершинаСтека-1] + " = " + Стек[ВершинаСтека]; 
		ДобавитьКонецСтроки(КусокКода, ИндОперации, ИгнорироватьКонецСтроки);  
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 17 Тогда 
		//Возврат (установить результат функции/метода))
		КусокКода = "Возврат " + Стек[ВершинаСтека];
		ДобавитьКонецСтроки(КусокКода, ИндОперации, ИгнорироватьКонецСтроки); 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);  
		
		ЗафиксироватьКонецБлока(СоответствиеБлоков, ИндОперации, ТекстТелаМетода);
		ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, ИндОперации, ТекстТелаМетода);
		
		ЗафиксироватьКонецБлока(СоответствиеБлоков, ИндОперации+1, ТекстТелаМетода);
		ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, ИндОперации+1, ТекстТелаМетода);
		
		ИндОперации = ИндОперации + 2;
		
	ИначеЕсли КодОперации = 18 Тогда 
		//Указание количества используемых параметров в следующем вызове (метода, функции)
		//
		//никак не обрабатываем саму операцию.
		//После нее идет имя вызываемомго метода, а он уже смотрим назад на 1 операцию,
		//чтобы выяснить сколько параметров из стека нужно забрать
		
	ИначеЕсли КодОперации = 19 Тогда 
		//Вызов локальной процедуры или функции
		
		ИндМетода= Операции[ИндОперации].Аргумент;
		КусокКода = Процедуры[ИндМетода].ИмяПроцедуры; 
		
		СчетчикАргументов = Операции[ИндОперации-1].Аргумент;
		
		МассивАргументов = Новый Массив; 
		
		Если СчетчикАргументов > 0 Тогда
			
			МассивАргументов = Новый Массив(СчетчикАргументов); 
			
			Пока СчетчикАргументов > 0 Цикл
				
				МассивАргументов[СчетчикАргументов-1] = ВернутьИзСтека(Стек, ВершинаСтека);
				
				СчетчикАргументов = СчетчикАргументов -1;	
				
			КонецЦикла; 
			
		КонецЕсли; 
		
		КусокКода = СтрШаблон("%1(%2)", КусокКода, СтрСоединить(МассивАргументов,", "));	
		
		ДобавитьКонецСтроки(КусокКода, ИндОперации, ИгнорироватьКонецСтроки);  
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода);
		
	ИначеЕсли КодОперации = 20 или //Выполнение метода .<Имя метода>() (являющегося процедурой, т.е. без возврата значения)  
		КодОперации = 21 Тогда  //Выполнение метода .<Имя метода>() (являющегося функцией, т.е. возвращающий значение)
		
		ИндКонстанты = Операции[ИндОперации].Аргумент;
		КусокКода = Константы[ИндКонстанты].Значение; 
		
		СчетчикАргументов = Операции[ИндОперации-1].Аргумент;
		
		МассивАргументов = Новый Массив; 
		
		Если СчетчикАргументов > 0 Тогда
			
			МассивАргументов = Новый Массив(СчетчикАргументов);
			
			Пока СчетчикАргументов > 0 Цикл
				
				МассивАргументов[СчетчикАргументов-1] = ВернутьИзСтека(Стек, ВершинаСтека);
				
				СчетчикАргументов = СчетчикАргументов -1;	
				
			КонецЦикла; 
			
		КонецЕсли;  
		
		ИмяМодуля = ВернутьИзСтека(Стек, ВершинаСтека);
		
		КусокКода = СтрШаблон("%1.%2(%3)", ИмяМодуля, КусокКода, СтрСоединить(МассивАргументов,", "));	
		
		ДобавитьКонецСтроки(КусокКода, ИндОперации, ИгнорироватьКонецСтроки); 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода); 
		
		
	ИначеЕсли КодОперации = 22 Тогда 
		//Конец блока (процедуры, модуля)
		Возврат;
		
	ИначеЕсли КодОперации = 23 Тогда 
		//Операция -(Minus)
		//это не вычитание, а установка противоположного знака
		КусокКода = "-" + Стек[ВершинаСтека];  
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);			
		
	ИначеЕсли КодОперации = 24 Тогда 
		//Операция +   
		УстановитьСкобкиПредыдущимЧленам(ИндОперации, КодОперации, Стек, ВершинаСтека);

		КусокКода = СтрШаблон("%1 + %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 25 Тогда 
		//Операция -
		УстановитьСкобкиПредыдущимЧленам(ИндОперации, КодОперации, Стек, ВершинаСтека);

		КусокКода = СтрШаблон("%1 - %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
	
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 26 Тогда 
		//Операция *
		УстановитьСкобкиПредыдущимЧленам(ИндОперации, КодОперации, Стек, ВершинаСтека);

		КусокКода = СтрШаблон("%1 * %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
	
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 27 Тогда 
		//Операция /
		УстановитьСкобкиПредыдущимЧленам(ИндОперации, КодОперации, Стек, ВершинаСтека);

		КусокКода = СтрШаблон("%1 / %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
	
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 28 Тогда 
		//Операция %
		УстановитьСкобкиПредыдущимЧленам(ИндОперации, КодОперации, Стек, ВершинаСтека);

		КусокКода = СтрШаблон("%1 %% %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
	
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 29 Тогда 
		//Операция Неа   
		Если БулевоСкобкиНужны(ИндОперации, КодОперации, Стек, ВершинаСтека) Тогда
			КусокКода = СтрШаблон("Не (%1)",Стек[ВершинаСтека]);  
		Иначе
			КусокКода = "Не " + Стек[ВершинаСтека];  
		КонецЕсли; 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);			
		
	ИначеЕсли КодОперации = 30 Тогда 
		//Операция И. Если операнд на вершине стека Ложь, то происходит переход
		//по адресу, указаному во втором параметре, т.е. пропуск вычисления второго
		//операнда, т.к. от него уже ничего не зависит. Из стека при этом значение
		//не удаляется (результатом операции является Ложь). Иначе, если на вершине
		//	стека Истина, из стека удаляется значение и перехода не происходит,
		//	т.е. вычисляется второй операнд, результат которого полностью определяет результат всей операции))
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "И");			
		
	ИначеЕсли КодОперации = 31 Тогда 
		//Операция Или. Если операнд на вершине стека Истина, то происходит переход
		//по адресу, указаному во втором параметре, т.е. пропуск вычисления второго
		//операнда, т.к. от него уже ничего не зависит. Из стека при этом значение 
		//не удаляется (результатом операции является Истина). Иначе, если на вершине 
		//	стека Ложь, из стека удаляется значение и перехода не происходит, т.е.
		//	вычисляется второй операнд, результат которого полностью определяет результат всей операции)
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "ИЛИ");			
		
	ИначеЕсли КодОперации = 32 Тогда
		//Unused
		ВызватьИсключение СтрШаблон("Не предусмотрен КодОперации=%1.",КодОперации);  
		
	ИначеЕсли КодОперации = 33 Тогда 
		//Операция = (сравнение)
		КусокКода = СтрШаблон("%1 = %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
	
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 34 Тогда
		//Операция <>
		КусокКода = СтрШаблон("%1 <> %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 35 Тогда
		//Операция >
		КусокКода = СтрШаблон("%1 > %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
	
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 36 Тогда
		//Операция <
		КусокКода = СтрШаблон("%1 < %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 37 Тогда
		//Операция >=
		КусокКода = СтрШаблон("%1 >= %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
	
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 38 Тогда
		//Операция <=
		КусокКода = СтрШаблон("%1 <= %2",Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
	
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода);			
		
	ИначеЕсли КодОперации = 39 Тогда
		//Переход на заданный шаг
				
		ИндПерехода= Операции[ИндОперации].Аргумент;
				
		Если Не ЭтоПрерватьПродолжитьВозврат(КодОперации, ИндОперации, Стек, ВершинаСтека, СоответствиеБлоков, ЭтоФункция) 
			И ИндПерехода > ИндОперации + 1 Тогда
			//если переход указывает дальше следующей строки
			//значит возможно нужно ставить "Иначе"
			
			НаличиеУсловияЭтогоБлока = Ложь;
			
			//ищем первую конструкцию "Если"/"ИначеЕсли" в остальных секциях ЭТОГО блока
			//если не находим - ставим "Иначе"
			//P.S.вложенные блоки не могут поместиться между окончанием ЭТОГО блока и следующей конструкцией
			//"ИначеЕсли" ЭТОГО блока - такие блоки будут ВНУТРИ ЭТОГО блока
			Для ОпережИндОперации = ИндОперации + 1 По ИндПерехода Цикл
				
				Если Операции[ОпережИндОперации].КодОперации = 40 Тогда
					
					ИндексПерехода = Операции[ОпережИндОперации].Аргумент; 
					ИндОкончанияБлокаСледующегоУсловия = Операции[ИндексПерехода-1].Аргумент;
					
					Если ИндПерехода = ИндОкончанияБлокаСледующегоУсловия Тогда
						НаличиеУсловияЭтогоБлока = Истина; 
					Иначе 
						//значит это конструкция вложенного блока
						//значит ставим "Иначе"
					КонецЕсли;  
					
					Прервать;
					
				КонецЕсли; 
				
			КонецЦикла;
			
			Если Не НаличиеУсловияЭтогоБлока Тогда
				//Ставим "Иначе"
				
				Если ВершинаСтека > -1 Тогда 
					КусокКода = Стек[ВершинаСтека] + Символы.ПС + Символы.ПС + "Иначе"; 
				Иначе 
					//когда несколько блоков заканчиваются подряд,
					//то они разделяются символом перевода строки
					//символ перевода строки уменьшает вершину стека
					//Может получится так что вершина ушла в минус
					ВершинаСтека = 0;
					КусокКода = "Иначе"; 
				КонецЕсли; 
				
				ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);			
				
			КонецЕсли; 
			
		КонецЕсли;     
		
		
	ИначеЕсли КодОперации = 40 Тогда
		//Переход, если Ложь 
		//это признак блочных констукций: условия, циклы
		
		ИндексПерехода = Операции[ИндОперации].Аргумент; 
		ИндПереходаСледОперации = Операции[ИндексПерехода-1].Аргумент; 
		
		Если ИндПереходаСледОперации < ИндОперации Тогда  
			//это цикл "Пока Условие Цикл"
			//циклы переходят назад 
			//цикл "Пока Условие Цикл" обрабатывается при операции = 1
			//из-за своей специфической конструкции   
			
			
		Иначе   
			
			ПерваяОперацияПослеБлока = Операции[ИндПереходаСледОперации].КодОперации;  
			
			Если ПерваяОперацияПослеБлока <> 1 Тогда
				//Проверка на конструкцию ?(Истина,1,2)
				
				Для ИндОперацииВнутр = ИндОперации + 1 По ИндПереходаСледОперации - 1 Цикл
					
					КодОперации = Операции[ИндОперацииВнутр].КодОперации;
					Если КодОперации = 1 Тогда
						//Перестрахуемся и не будет реагировать на перевод строки
						Продолжить;
					КонецЕсли;
					Если КодОперации = 39 Тогда
						//дошли до 2-й части условия
						
						//ДиапазонЦикла = ВернутьИзСтека(Стек, ВершинаСтека);
						
						Продолжить;
					КонецЕсли;
					
					ОбработатьОперацию(ИндОперацииВнутр, ИндПроцедуры, ТекстТелаМетода, Стек, ВершинаСтека, ПоследнийИндексОпераций, СоответствиеМетокПерехода, СоответствиеБлоков, Исключения, Истина, ЭтоФункция);
					
				КонецЦикла; 
				
				КусокКода = СтрШаблон("?(%1, %2, %3)",Стек[ВершинаСтека-2], Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
				
				ДобавитьВСтек(Стек, ВершинаСтека, -2, КусокКода);			
				
				ИндОперации = ИндОперацииВнутр - 1;
				
			Иначе 
				//Это Условие
				//условия переходят вперед
				
				Если СоответствиеБлоков.Получить(ИндПереходаСледОперации) = Неопределено Тогда
					КусокКода = "Если " + Стек[ВершинаСтека] + " Тогда";    
					//добавляем 1 раз(внутри могут быть циклы, которые ссылаются на тот же конец)
					//и они должны устанавливать КонецЦикла перед существующим КонецЕсли
					СоответствиеБлоков.Вставить(ИндПереходаСледОперации, "КонецЕсли;"); 
				Иначе 
					КусокКода = "ИначеЕсли " + Стек[ВершинаСтека] + " Тогда";  
				КонецЕсли; 
				
				ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);
			КонецЕсли;
			
		КонецЕсли; 
		
	ИначеЕсли КодОперации = 41 Тогда
		//Переход, если Истина
		//Компилятор 1С эту команду никогда не использует
		//ВызватьИсключение СтрШаблон("Не предусмотрен КодОперации=%1.",КодОперации);  
		
		ИндексПерехода = Операции[ИндОперации].Аргумент; 
		ИндПереходаСледОперации = Операции[ИндексПерехода-1].Аргумент; 
		
		Если ИндПереходаСледОперации < ИндОперации Тогда  
			//это цикл "Пока Условие Цикл"
			//циклы переходят назад 
			//цикл "Пока Условие Цикл" обрабатывается при операции = 1
			//из-за своей специфической конструкции   
			
			
		Иначе   
			
			ПерваяОперацияПослеБлока = Операции[ИндПереходаСледОперации].КодОперации;  
			
			Если ПерваяОперацияПослеБлока <> 1 Тогда
				//Проверка на конструкцию ?(Истина,1,2)
				
				Для ИндОперацииВнутр = ИндОперации + 1 По ИндПереходаСледОперации - 1 Цикл
					
					КодОперации = Операции[ИндОперацииВнутр].КодОперации;
					Если КодОперации = 1 Тогда
						//Перестрахуемся и не будет реагировать на перевод строки
						Продолжить;
					КонецЕсли;
					Если КодОперации = 39 Тогда
						//дошли до 2-й части условия
						
						//ДиапазонЦикла = ВернутьИзСтека(Стек, ВершинаСтека);
						
						Продолжить;
					КонецЕсли;
					
					ОбработатьОперацию(ИндОперацииВнутр, ИндПроцедуры, ТекстТелаМетода, Стек, ВершинаСтека, ПоследнийИндексОпераций, СоответствиеМетокПерехода, СоответствиеБлоков, Исключения, Истина, ЭтоФункция);
					
				КонецЦикла; 
				
				КусокКода = СтрШаблон("?(%1, %2, %3)",Стек[ВершинаСтека-2], Стек[ВершинаСтека-1], Стек[ВершинаСтека]);  
				
				ДобавитьВСтек(Стек, ВершинаСтека, -2, КусокКода);			
				
				ИндОперации = ИндОперацииВнутр - 1;
				
			Иначе 
				//Это Условие
				//условия переходят вперед
				
				Если СоответствиеБлоков.Получить(ИндПереходаСледОперации) = Неопределено Тогда
					КусокКода = "Если НЕ" + Стек[ВершинаСтека] + " Тогда";    
					//добавляем 1 раз(внутри могут быть циклы, которые ссылаются на тот же конец)
					//и они должны устанавливать КонецЦикла перед существующим КонецЕсли
					СоответствиеБлоков.Вставить(ИндПереходаСледОперации, "КонецЕсли;"); 
				Иначе 
					КусокКода = "ИначеЕсли НЕ" + Стек[ВершинаСтека] + " Тогда";  
				КонецЕсли; 
				
				ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);
			КонецЕсли;
			
		КонецЕсли;
	ИначеЕсли КодОперации = 42 Тогда 
		//Перейти 
		
		КусокКода = "Перейти " + Процедуры[ИндПроцедуры].МеткиПерехода[Операции[ИндОперации].Аргумент].ИмяМетки + ";";
		
		ТекстТелаМетода = ТекстТелаМетода + Символы.ПС + Символы.ПС + КусокКода;
		
	ИначеЕсли КодОперации = 43 Тогда 
		//Инкремент
		//Это увеличение локальной переменной цикла
		//перед инкрементом в стек загружается локальная переменная,
		//которая потом в конце цикла увеличивается на 1(инкремент)
		//но инкремент не виден в коде 1С, а локальная переменная остается в стеке
		//поэтому просто уменьшим вершину стека
		ВершинаСтека = ВершинаСтека - 1;
		
	ИначеЕсли КодОперации = 44 Тогда 
		//Попытка
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "Попытка");
		
	ИначеЕсли КодОперации = 45 Тогда 
		//Завершение блока (Процедура, Функция, Попытка) без ошибки (Возврат или Исключение) 
		
		Если Исключения.Найти(ИндОперации) <> Неопределено Тогда
			ДобавитьВСтек(Стек, ВершинаСтека, 1, "Исключение");   
			
			//далее идет операция 39, которая прыгает в конец попытки
			//нам это отслеживать не надо
			
			//фиксируем концы блоков для пропускаемых операцией	
			ЗафиксироватьКонецБлока(СоответствиеБлоков, ИндОперации, ТекстТелаМетода);     
			ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, ИндОперации, ТекстТелаМетода);
			
			ИндОперации = ИндОперации +1;
		КонецЕсли; 
		
	ИначеЕсли КодОперации = 46 Тогда 
		//КонецПопытки (конец обработки ошибки)
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, "КонецПопытки;");
		
	ИначеЕсли КодОперации = 47 Тогда 
		//ВызватьИсключение
		
		КусокКода = "ВызватьИсключение";
		
		Если Операции[ИндОперации].Аргумент = 1 Тогда
			
			КусокКода = КусокКода + " " + ВернутьИзСтека(Стек, ВершинаСтека);
			
		КонецЕсли; 
		
		ДобавитьКонецСтроки(КусокКода, ИндОперации, ИгнорироватьКонецСтроки);  
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода);
		
	ИначеЕсли КодОперации = 48 Тогда 
		//Создать на стеке временных переменных временную переменную
		
		//сейчас в стеке находится первая часть "i=0"
		//нам нужно получить остальную часть шапки и 
		//зафиксировать индекс операции конца цикла  
		
		
		ДиапазонЦикла = "";    
		
		Для ИндОперацииДиапазонЦикла = ИндОперации + 2 По ПоследнийИндексОпераций Цикл
			
			КодОперации = Операции[ИндОперацииДиапазонЦикла].КодОперации;
			Если КодОперации = 1 или 
				КодОперации = 14 или
				КодОперации = 16 Тогда
				//далее уже смотреть нельзя, там служебные операции идут
				
				ДиапазонЦикла = ВернутьИзСтека(Стек, ВершинаСтека);
				
				Прервать;
			КонецЕсли;
			
			ОбработатьОперацию(ИндОперацииДиапазонЦикла, ИндПроцедуры, ТекстТелаМетода, Стек, ВершинаСтека, ПоследнийИндексОпераций, СоответствиеМетокПерехода, СоответствиеБлоков, Исключения, Ложь, ЭтоФункция);
						
		КонецЦикла;
		
		Если ДиапазонЦикла = "" Тогда
			
			ВызватьИсключение "не определено конечное значение в цикле";	
			
		КонецЕсли;  
		
		//зафиксировать индекс операции конца цикла
		
		КонецЦиклаНайден = Ложь;
		
		Для ОпережИндОперации = ИндОперацииДиапазонЦикла По ПоследнийИндексОпераций Цикл
			
			ОпережКодОперации = Операции[ОпережИндОперации].КодОперации;
			
			Если ОпережКодОперации = 40 Тогда
				
				ИндексПерехода = Операции[ОпережИндОперации].Аргумент;
				Если Операции[ИндексПерехода].КодОперации = 50 Тогда
					
					СоответствиеБлоков.Вставить(ИндексПерехода, "КонецЦикла;");
					КонецЦиклаНайден = Истина;
					Прервать;
					
				КонецЕсли; 
				
			КонецЕсли;   
			
		КонецЦикла;
		
		Если Не КонецЦиклаНайден Тогда
			
			ВызватьИсключение СтрШаблон("Не найден КонецЦикла, для цикла оканчивающегося на ""%1""
			|(показыно значение, которое будет между звездочками):
			|-(Для i = 0 по *ДиапазонЦикла*)
			|-(Для каждого Стр Из *ДиапазонЦикла*)",ДиапазонЦикла);	
			
		КонецЕсли; 
		
		Если ВершинаСтека > -1 Тогда 
			//это признак шапки цикла "Для i=0 По 5 Цикл"
			//получаем шапку
			КусокКода = "Для " + Стек[ВершинаСтека] + " По " + ДиапазонЦикла + " Цикл"; 
		Иначе 
			//Значит это цикл "Для Каждого Стр Из ТЗ Цикл"
			//имя переменной идет следом за кодом операции 40, которая ссылается на КонецЦикла
			ИндПеременной = Операции[ОпережИндОперации+1].Аргумент;
			ИмяПеременной = Процедуры[ИндПроцедуры].Переменные[ИндПеременной].ИмяПеременной; 
			
			КусокКода = "Для каждого " + ИмяПеременной + " Из " + ДиапазонЦикла + " Цикл"; 
			ВершинаСтека = 0;
		КонецЕсли;
		
		//промотаем операции, которые не отображаются в 1С до символа новой строки
		//Для СледующийИндОперации = ОпережИндОперации По ПоследнийИндексОпераций Цикл
		//	
		//	//смотрим на +1, т.к. будет автоинкремент еще
		//	ОпережКодОперации = Операции[СледующийИндОперации+1].КодОперации;
		//	
		//	Если ОпережКодОперации = 3 или ОпережКодОперации = 8 или ОпережКодОперации = 16 Тогда
		//		//фиксируем концы блоков для пропускаемых операцией	
		//		ЗафиксироватьКонецБлока(СоответствиеБлоков, СледующийИндОперации, ТекстТелаМетода);
		//		ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, СледующийИндОперации, ТекстТелаМетода);
		//	Иначе 
		//		Прервать; 
		//	КонецЕсли;   
		//	
		//КонецЦикла; 
		СледующийИндОперации = ОпережИндОперации;
		
		Если ПоследнийИндексОпераций >= ОпережИндОперации+6 Тогда
			
			//Для цикла "Для каждого Стр Из ТЗ" добавляется 6 операций всегда
			//если эти операции есть - значит их пропускаем
			ОпережКодОперации1 = Операции[ОпережИндОперации+1].КодОперации;
			ОпережКодОперации2 = Операции[ОпережИндОперации+2].КодОперации;
			ОпережКодОперации3 = Операции[ОпережИндОперации+3].КодОперации;
			ОпережКодОперации4 = Операции[ОпережИндОперации+4].КодОперации;
			ОпережКодОперации5 = Операции[ОпережИндОперации+5].КодОперации;
			ОпережКодОперации6 = Операции[ОпережИндОперации+6].КодОперации;
			
			Если ОпережКодОперации1 = 3 и ОпережКодОперации2 = 3 и ОпережКодОперации3 = 16 и
				ОпережКодОперации4 = 3 и ОпережКодОперации5 = 8 и ОпережКодОперации6 = 16 Тогда
				
				Для СледующийИндОперации = ОпережИндОперации По ОпережИндОперации+5 Цикл
					
					ЗафиксироватьКонецБлока(СоответствиеБлоков, СледующийИндОперации, ТекстТелаМетода);
					ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, СледующийИндОперации, ТекстТелаМетода);
					
				КонецЦикла;
				
			КонецЕсли; 
			
		КонецЕсли; 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);
		
		ИндОперации = СледующийИндОперации;
				
	ИначеЕсли КодОперации = 49 Тогда
		//Загрузить в стек временную переменную из стека временных переменных 
		
		//это операция не видна в коде 1С идет в конструкциях цикла
		//если она встречается отдельно - значит это что-то непредусмотренное
		ВызватьИсключение СтрШаблон("Не предусмотрен КодОперации=%1.",КодОперации);  
		
		
	ИначеЕсли КодОперации = 50 Тогда 
		//Удалить из стека временных переменных временную переменную
		//это операция, которая есть только в блоке окончания цикла
		
		//промотаем операции, которые не отображаются в 1С до символа новой строки
		
		//смотрим на +1, т.к. будет автоинкремент еще    
		
		Если ПоследнийИндексОпераций >= ИндОперации+6 Тогда
			
			//Для цикла "Для каждого Стр Из ТЗ" добавляется 6 операций всегда
			//если эти операции есть - значит их пропускаем
			ОпережКодОперации1 = Операции[ИндОперации+1].КодОперации;
			ОпережКодОперации2 = Операции[ИндОперации+2].КодОперации;
			ОпережКодОперации3 = Операции[ИндОперации+3].КодОперации;
			ОпережКодОперации4 = Операции[ИндОперации+4].КодОперации;
			ОпережКодОперации5 = Операции[ИндОперации+5].КодОперации;
			ОпережКодОперации6 = Операции[ИндОперации+6].КодОперации;
			
			Если ОпережКодОперации1 = 3 и ОпережКодОперации2 = 8 и ОпережКодОперации3 = 16 и
				ОпережКодОперации4 = 3 и ОпережКодОперации5 = 8 и ОпережКодОперации6 = 16 Тогда
				
				Для СледующийИндОперации = ИндОперации По ИндОперации+5 Цикл
					
					ЗафиксироватьКонецБлока(СоответствиеБлоков, СледующийИндОперации, ТекстТелаМетода);
					ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, СледующийИндОперации, ТекстТелаМетода);
					
				КонецЦикла;
				//промотаем операции, которые не отображаются в 1С до символа новой строки
				ИндОперации = СледующийИндОперации;	
				
			КонецЕсли; 
			
		КонецЕсли; 
		
	ИначеЕсли КодОперации = 51 Тогда 
		//Новый
		
		ИндКонстанты = Операции[ИндОперации].Аргумент;
		КусокКода = "Новый " + Константы[ИндКонстанты].Значение; 
		
		СчетчикАргументов = Операции[ИндОперации-1].Аргумент;
		
		Если СчетчикАргументов > 0 Тогда
			
			МассивАргументов = Новый Массив(СчетчикАргументов);
			
			Пока СчетчикАргументов > 0 Цикл
				
				МассивАргументов[СчетчикАргументов-1] = ВернутьИзСтека(Стек, ВершинаСтека);
				
				СчетчикАргументов = СчетчикАргументов -1;	
				
			КонецЦикла; 
			
			КусокКода = СтрШаблон("%1(%2)", КусокКода, СтрСоединить(МассивАргументов,", "));	
			
		КонецЕсли; 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода); 
		
	ИначеЕсли КодОперации = 52 Тогда
		//Выполнить    
		
		КусокКода = СтрШаблон("Выполнить(%1);", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 53 Тогда 
		//СтрДлина  
		
		КусокКода = СтрШаблон("СтрДлина(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 54 Тогда 
		//СокрЛ
		
		КусокКода = СтрШаблон("СокрЛ(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 55 Тогда 
		//СокрП
		
		КусокКода = СтрШаблон("СокрП(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 56 Тогда 
		//СокрЛП
		
		КусокКода = СтрШаблон("СокрЛП(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 57 Тогда 
		//Лев
		
		КусокКода = СтрШаблон("Лев(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 58 Тогда 
		//Прав
		
		КусокКода = СтрШаблон("Прав(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 59 Тогда 
		//Сред
		
		КусокКода = СтрШаблон("Сред(%1, %2, %3)", Стек[ВершинаСтека-2], Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -2, КусокКода);
		
	ИначеЕсли КодОперации = 60 Тогда 
		//Найти
		
		КусокКода = СтрШаблон("Найти(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 61 Тогда 
		//Врег
		
		КусокКода = СтрШаблон("Врег(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 62 Тогда 
		//Нрег
		
		КусокКода = СтрШаблон("Нрег(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 63 Тогда 
		//Символ
		
		КусокКода = СтрШаблон("Символ(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 64 Тогда 
		//КодСимвола
		
		КусокКода = СтрШаблон("КодСимвола(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 65 Тогда 
		//ПустаяСтрока
		
		КусокКода = СтрШаблон("ПустаяСтрока(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 66 Тогда 
		//Цел
		
		КусокКода = СтрШаблон("Цел(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 67 Тогда 
		//Системная функция Окр
		
		КусокКода = СтрШаблон("Окр(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 68 Тогда 
		//Системная функция Окр
		
		КусокКода = СтрШаблон("Окр(%1, %2, %3)", Стек[ВершинаСтека-2], Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -2, КусокКода);
		
	ИначеЕсли КодОперации = 69 Тогда 
		//Системная функция Булево
		Если БулевоСкобкиНужны(ИндОперации, КодОперации, Стек, ВершинаСтека) Тогда 
			КусокКода = СтрШаблон("(%1 %2 %3)", Стек[ВершинаСтека-2], Стек[ВершинаСтека-1] , Стек[ВершинаСтека]);  
		Иначе
			КусокКода = СтрШаблон("%1 %2 %3", Стек[ВершинаСтека-2], Стек[ВершинаСтека-1] , Стек[ВершинаСтека]);  
		КонецЕсли;
	
		ДобавитьВСтек(Стек, ВершинаСтека, -2, КусокКода);			
		
	ИначеЕсли КодОперации = 70 Тогда 
		//Число  
		
		КусокКода = СтрШаблон("Число(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 71 Тогда 
		//Строка
		
		КусокКода = СтрШаблон("Строка(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 72 Тогда 
		//Дата
		
		КусокКода = СтрШаблон("Дата(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 73 Тогда 
		//Дата    
		
		КусокКода = СтрШаблон("Дата(%1, %2, %3)", Стек[ВершинаСтека-2], Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -2, КусокКода);
		
	ИначеЕсли КодОперации = 74 Тогда 
		//Дата    
		
		КусокКода = СтрШаблон("Дата(%1, %2, %3, %4, %5, %6)",
		Стек[ВершинаСтека-5], Стек[ВершинаСтека-4],
		Стек[ВершинаСтека-3], Стек[ВершинаСтека-2],
		Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -5, КусокКода);
		
	ИначеЕсли КодОперации = 75 Тогда 
		//ДобавитьМесяц    
		
		КусокКода = СтрШаблон("ДобавитьМесяц(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 76 Тогда 
		//НачалоМесяца    
		
		КусокКода = СтрШаблон("НачалоМесяца(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 77 Тогда 
		//КонецМесяца    
		
		КусокКода = СтрШаблон("КонецМесяца(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 78 Тогда 
		//НачалоКвартала    
		
		КусокКода = СтрШаблон("НачалоКвартала(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 79 Тогда 
		//КонецКвартала    
		
		КусокКода = СтрШаблон("КонецКвартала(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 80 Тогда 
		//НачалоГода    
		
		КусокКода = СтрШаблон("НачалоГода(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 81 Тогда 
		//КонецГода    
		
		КусокКода = СтрШаблон("КонецГода(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 82 Тогда 
		//Год    
		
		КусокКода = СтрШаблон("Год(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 83 Тогда 
		//Месяц    
		
		КусокКода = СтрШаблон("Месяц(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 84 Тогда 
		//День    
		
		КусокКода = СтрШаблон("День(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 85 Тогда 
		//Час    
		
		КусокКода = СтрШаблон("Час(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 86 Тогда 
		//Минута    
		
		КусокКода = СтрШаблон("Минута(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 87 Тогда 
		//Секунда    
		
		КусокКода = СтрШаблон("Секунда(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 88 Тогда 
		//ДеньГода    
		
		КусокКода = СтрШаблон("ДеньГода(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 89 Тогда 
		//НеделяГода    
		
		КусокКода = СтрШаблон("НеделяГода(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 90 Тогда 
		//ДеньНедели    
		
		КусокКода = СтрШаблон("ДеньНедели(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 91 Тогда 
		//НачалоНедели    
		
		КусокКода = СтрШаблон("НачалоНедели(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 92 Тогда 
		//КонецНедели    
		
		КусокКода = СтрШаблон("КонецНедели(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 93 Тогда 
		//НачалоДня    
		
		КусокКода = СтрШаблон("НачалоДня(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 94 Тогда 
		//КонецДня    
		
		КусокКода = СтрШаблон("КонецДня(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 95 Тогда 
		//НачалоЧаса    
		
		КусокКода = СтрШаблон("НачалоЧаса(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 96 Тогда 
		//КонецЧаса    
		
		КусокКода = СтрШаблон("КонецЧаса(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 97 Тогда 
		//НачалоМинуты    
		
		КусокКода = СтрШаблон("НачалоМинуты(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 98 Тогда 
		//КонецМинуты    
		
		КусокКода = СтрШаблон("КонецМинуты(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 99 Тогда 
		//ТекущаяДата    
		
		КусокКода = "ТекущаяДата()";
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода); 
		
	ИначеЕсли КодОперации = 100 Тогда 
		//СтрЗаменить    
		
		КусокКода = СтрШаблон("СтрЗаменить(%1, %2, %3)", Стек[ВершинаСтека-2], Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -2, КусокКода);
		
	ИначеЕсли КодОперации = 101 Тогда 
		//СтрЧислоСтрок    
		
		КусокКода = СтрШаблон("СтрЧислоСтрок(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 102 Тогда 
		//СтрПолучитьСтроку    
		
		КусокКода = СтрШаблон("СтрПолучитьСтроку(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 103 Тогда 
		//Мин    
		
		СчетчикАргументов = Операции[ИндОперации-1].Аргумент;
		
		МассивАргументов = Новый Массив;
		
		Если СчетчикАргументов > 0 Тогда
			
			МассивАргументов = Новый Массив(СчетчикАргументов);
			
			Пока СчетчикАргументов > 0 Цикл
				
				МассивАргументов[СчетчикАргументов-1] = ВернутьИзСтека(Стек, ВершинаСтека);
				
				СчетчикАргументов = СчетчикАргументов -1;	
				
			КонецЦикла; 
			
		КонецЕсли; 
		
		КусокКода = СтрШаблон("Мин(%1)", СтрСоединить(МассивАргументов,", "));	
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода); 
		
	ИначеЕсли КодОперации = 104 Тогда 
		//Макс    
		
		СчетчикАргументов = Операции[ИндОперации-1].Аргумент;
		
		МассивАргументов = Новый Массив;
		
		Если СчетчикАргументов > 0 Тогда
			
			МассивАргументов = Новый Массив(СчетчикАргументов);
			
			Пока СчетчикАргументов > 0 Цикл
				
				МассивАргументов[СчетчикАргументов-1] = ВернутьИзСтека(Стек, ВершинаСтека);
				
				СчетчикАргументов = СчетчикАргументов -1;	
				
			КонецЦикла; 
			
		КонецЕсли; 
		
		КусокКода = СтрШаблон("Макс(%1)", СтрСоединить(МассивАргументов,", "));	
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода); 
		
	ИначеЕсли КодОперации = 105 Тогда 
		//СтрЧислоВхождений    
		
		КусокКода = СтрШаблон("СтрЧислоВхождений(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 106 Тогда 
		//ОписаниеОшибки    
		
		КусокКода = "ОписаниеОшибки()";
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода); 
		
	ИначеЕсли КодОперации = 107 Тогда 
		//ТипЗнч    
		
		КусокКода = СтрШаблон("ТипЗнч(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 108 Тогда 
		//Тип    
		
		КусокКода = СтрШаблон("Тип(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 109 Тогда 
		//Вычислить    
		
		КусокКода = СтрШаблон("Вычислить(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 110 Тогда 
		//Формат    
		
		КусокКода = СтрШаблон("Формат(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 111 Тогда 
		//Новый    
		
		КусокКода = СтрШаблон("Новый(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 112 Тогда 
		//Системная функция ACos    
		
		КусокКода = СтрШаблон("ACos(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 113 Тогда 
		//Системная функция ASin    
		
		КусокКода = СтрШаблон("ASin(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 114 Тогда 
		//Системная функция ATan    
		
		КусокКода = СтрШаблон("ATan(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 115 Тогда 
		//Системная функция Cos    
		
		КусокКода = СтрШаблон("Cos(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 116 Тогда 
		//Системная функция Exp    
		
		КусокКода = СтрШаблон("Exp(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 117 Тогда 
		//Системная функция Log    
		
		КусокКода = СтрШаблон("Log(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 118 Тогда 
		//Системная функция Log10    
		
		КусокКода = СтрШаблон("Log10(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 119 Тогда 
		//Системная функция Pow    
		
		КусокКода = СтрШаблон("Pow(%1, %2)", Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 120 Тогда 
		//Системная функция Sin    
		
		КусокКода = СтрШаблон("Sin(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 121 Тогда 
		//Системная функция Sqrt    
		
		КусокКода = СтрШаблон("Sqrt(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 122 Тогда 
		//Системная функция Tan    
		
		КусокКода = СтрШаблон("Tan(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 123 Тогда 
		//ДобавитьОбработчик    
		
		ИндМетода= Операции[ИндОперации].Аргумент;
		ИмяПроцедуры = Процедуры[ИндМетода].ИмяПроцедуры; 
		
		КусокКода = СтрШаблон("ДобавитьОбработчик %1.%2, %3;",
		Стек[ВершинаСтека-1], Стек[ВершинаСтека], ИмяПроцедуры);
		
		КусокКода = СтрЗаменить(КусокКода, """", "");
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 124 Тогда 
		//ДобавитьОбработчик    
		
		КусокКода = СтрШаблон("ДобавитьОбработчик %1.%2, %3.%4;",
		Стек[ВершинаСтека-3], Стек[ВершинаСтека-2],
		Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		КусокКода = СтрЗаменить(КусокКода, """", "");
		ДобавитьВСтек(Стек, ВершинаСтека, -3, КусокКода); 
		
	ИначеЕсли КодОперации = 125 Тогда 
		//УдалитьОбработчик    
		
		ИндМетода= Операции[ИндОперации].Аргумент;
		ИмяПроцедуры = Процедуры[ИндМетода].ИмяПроцедуры; 
		
		КусокКода = СтрШаблон("УдалитьОбработчик %1.%2, %3;",
		Стек[ВершинаСтека-1], Стек[ВершинаСтека], ИмяПроцедуры);
		
		КусокКода = СтрЗаменить(КусокКода, """", "");
		
		ДобавитьВСтек(Стек, ВершинаСтека, -1, КусокКода); 
		
	ИначеЕсли КодОперации = 126 Тогда 
		//УдалитьОбработчик    
		
		КусокКода = СтрШаблон("УдалитьОбработчик %1.%2, %3.%4;",
		Стек[ВершинаСтека-3], Стек[ВершинаСтека-2],
		Стек[ВершинаСтека-1], Стек[ВершинаСтека]);
		
		КусокКода = СтрЗаменить(КусокКода, """", "");
		ДобавитьВСтек(Стек, ВершинаСтека, -3, КусокКода); 
		
	ИначеЕсли КодОперации = 127 Тогда 
		//ТРег    
		
		КусокКода = СтрШаблон("ТРег(%1)", Стек[ВершинаСтека]);
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода); 
		
	ИначеЕсли КодОперации = 128 Тогда 
		//ИнформацияОбОшибке    
		
		КусокКода = "ИнформацияОбОшибке()";
		
		ДобавитьВСтек(Стек, ВершинаСтека, 1, КусокКода); 
		
	Иначе 
		ВызватьИсключение СтрШаблон("Не предусмотрен КодОперации=%1. Индекс операции:%2",КодОперации, ИндОперации);  
		
	КонецЕсли; 
	
	ЗафиксироватьКонецБлока(СоответствиеБлоков, ИндОперации, ТекстТелаМетода);
	ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, ИндОперации, ТекстТелаМетода);
	
КонецПроцедуры

Процедура ЗафиксироватьКонецБлока(СоответствиеБлоков, ИндОперации, ТекстТелаМетода)

	ОкончаниеБлока = СоответствиеБлоков.Получить(ИндОперации); 
	
	Если ОкончаниеБлока <> Неопределено Тогда
		
		ТекстТелаМетода = ТекстТелаМетода + Символы.ПС + Символы.ПС + ОкончаниеБлока;
		
	КонецЕсли; 

КонецПроцедуры

Процедура ЗафиксироватьМеткуПерехода(СоответствиеМетокПерехода, ИндОперации, ТекстТелаМетода)
	
	МеткаПерехода = СоответствиеМетокПерехода.Получить(ИндОперации); 
	
	Если МеткаПерехода <> Неопределено Тогда
		
		ТекстТелаМетода = ТекстТелаМетода + Символы.ПС + Символы.ПС + МеткаПерехода + ":";
		
	КонецЕсли; 

КонецПроцедуры

Процедура ДобавитьВСтек(Стек, ВершинаСтека, Смещение = 0, КусокКода = "")
	
	ВершинаСтека = ВершинаСтека + Смещение;
	Стек[ВершинаСтека] = КусокКода;

КонецПроцедуры

Функция ВернутьИзСтека(Стек, ВершинаСтека)
	
	ЗначениеСтека = "";
	
	Если ВершинаСтека > -1 Тогда
		
		ЗначениеСтека = Стек[ВершинаСтека];
		ВершинаСтека = ВершинаСтека -1;
		
	КонецЕсли; 
	
	Возврат ЗначениеСтека;
	
КонецФункции

Процедура ДобавитьКонецСтроки(СтрокаКода, ИндОперации, Отмена)
	
	Если Отмена Тогда
		Возврат;
	КонецЕсли;
	
	СледКодОперации = Операции[ИндОперации+1].КодОперации;
	
	Если СледКодОперации = 1 или //Начало строки кода
		СледКодОперации = 39 или //Переход на заданный шаг
		СледКодОперации = 44 или //Попытка
		СледКодОперации = 45 //Завершение блока (Процедура, Функция, Попытка) без ошибки (Возврат или Исключение)
		Тогда
		
		СтрокаКода = СтрокаКода + ";";
		
	КонецЕсли; 
	
КонецПроцедуры// ДобавитьКонецСтроки()
 

Функция ПолучитьПредставлениеПоТипу(ТипСтрокой, Значение)
	
	//Типы.Вставить("""N""", "Число");
	//Типы.Вставить("""S""", "Строка");
	//Типы.Вставить("""B""", "Булево");
	//Типы.Вставить("""D""", "Дата");
	//Типы.Вставить("""L""", "Null");
	//Типы.Вставить("""U""", "Неопределено");
	
	Если ТипСтрокой = "Строка" Тогда
		
		ЗначениеФормат = стрзаменить(Значение, Символы.ПС, Символы.ПС + "|");
		ЗначениеФормат = стрзаменить(ЗначениеФормат, """", """""");
		
		ПредставлениеПоТипу = СтрШаблон("""%1""", ЗначениеФормат);  
		
	ИначеЕсли ТипСтрокой = "Дата" Тогда
		
		Если СтрДлина(Значение) = 14 и Сред(Значение,9,-1) = "000000" Тогда
		
			Значение = Лев(Значение,8);	
		
		КонецЕсли;    
		
		ПредставлениеПоТипу = СтрШаблон("'%1'", СтрЗаменить(Значение, Символы.НПП, ""));
		
	ИначеЕсли ТипСтрокой = "Число" Тогда
		
		ПредставлениеПоТипу = СтрЗаменить(СтрЗаменить(Значение, Символы.НПП, ""), ",", ".");

	Иначе 
		
		ПредставлениеПоТипу = Значение;
		
	КонецЕсли;  
	
	Возврат ПредставлениеПоТипу;
	
КонецФункции // ПолучитьПредставлениеПоТипу()

&НаКлиенте
Процедура ПрочитатьЗакрытыйМодуль(Команда)
	
	Если ТипМодуля = 0 Тогда //Общий модуль
		НовоеИмяФайла = "Module.bin";	
	ИначеЕсли ТипМодуля = 1 Тогда //Модуль обработки
		НовоеИмяФайла = "ObjectModule.bin";	
	КонецЕсли; 
	
	ВыборФайла = Новый ДиалогВыбораФайла(РежимДиалогаВыбораФайла.Открытие);
	ВыборФайла.Заголовок                 = "Выберите файлы с закрытыми модулями";
	ВыборФайла.ПолноеИмяФайла = НовоеИмяФайла;
	ВыборФайла.Фильтр                    = "Закрытый модуль (bin)|*.bin";
	
	ОписаниеОповещения = Новый ОписаниеОповещения("ОбработкаПрочитатьЗакрытыйМодуль", ЭтотОбъект);
	НачатьПомещениеФайлов(ОписаниеОповещения, , ВыборФайла , Истина, Новый УникальныйИдентификатор);
	
КонецПроцедуры


&НаКлиенте
Процедура ОбработкаПрочитатьЗакрытыйМодуль(Результат, ДопПараметры) Экспорт
	
	Если Результат = Неопределено Тогда
		
		Возврат;	
		
	КонецЕсли; 
	
	Успех = Ложь;
	
	Для каждого Эл Из Результат Цикл
		
		Успех = Истина;
		Адрес = Эл.Хранение;
		ВыбранноеИмя = Эл.ПолноеИмя;
	
	КонецЦикла;

	Если Не Успех Тогда
		Сообщение = Новый СообщениеПользователю;
		Сообщение.Текст = "Не удолось открыть файл";
		Сообщение.Сообщить();  
		Возврат;
	КонецЕсли; 
	
	ДД = ПолучитьИзВременногоХранилища(Адрес);
	Чтение = Новый ЧтениеТекста(ДД.ОткрытьПотокДляЧтения());
	Текст = Чтение.Прочитать();  
	
	ДлинаСтроки = СтрДлина(Текст);
	
	НужныеСимволы = Новый Массив;
	СчетчикФигурныхСкобок = 0;
	АдресПервогоБлока = Найти(Текст, "{"); 
	
	Если АдресПервогоБлока > 0 Тогда
		
		Для i = АдресПервогоБлока По ДлинаСтроки Цикл
			
			ТекущийСимвол = Сред(Текст, i, 1);
			
			Если ТекущийСимвол = "{" Тогда
				СчетчикФигурныхСкобок = СчетчикФигурныхСкобок + 1;	
			ИначеЕсли ТекущийСимвол = "}" Тогда
				СчетчикФигурныхСкобок = СчетчикФигурныхСкобок - 1;	
			КонецЕсли; 
			
			НужныеСимволы.Добавить(ТекущийСимвол);
			
			Если СчетчикФигурныхСкобок = 0 Тогда
				
				Прервать;	
				
			КонецЕсли; 
			
		КонецЦикла;  
		
	КонецЕсли; 
	
	НужныйТекст = СтрСоединить(НужныеСимволы);
	
	//ВыбранноеИмя = C:\forDecompile\data\config\DataProcessors\Simple\Ext\ObjectModule.bin
	ПозицияГраницыКаталога = СтрНайти(ВыбранноеИмя, "\", НаправлениеПоиска.СКонца, СтрДлина(ВыбранноеИмя)); 
	Каталог = Сред(ВыбранноеИмя, 1, ПозицияГраницыКаталога);
	НовоеИмяФайла = Каталог + "image";	
	                          	
	Запись = Новый ЗаписьТекста(НовоеИмяФайла, КодировкаТекста.ANSI);

	Запись.Записать(НужныйТекст); 
	Запись.Закрыть();
	
	АдресВХ = ПоместитьВоВременноеХранилище(Новый ДвоичныеДанные(НовоеИмяФайла));
	
	ОбработкаВыбораФайла(Истина, АдресВХ, НовоеИмяФайла, Неопределено);
	
КонецПроцедуры // ОбработкаВыбораФайла()

Функция ЭтоПрерватьПродолжитьВозврат(КодОперации, ИндОперации, Стек, ВершинаСтека, СоответствиеБлоков, ЭтоФункция)
	
	Если КодОперации <> 39 Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	//Переход на заданный шаг
	
	ИндПерехода= Операции[ИндОперации].Аргумент;
	
	ОперацияПерехода = Операции[ИндПерехода].КодОперации;
	ОперацияПослеПерехода = Операции[ИндПерехода+1].КодОперации;
	ИндСледПерехода = Операции[ИндПерехода].Аргумент; 
	
	//проверка на "Возврат"   
	Если Не ЭтоФункция И ОперацияПослеПерехода = 22 Тогда
	    //переход в самый конец процедуры это возврат
		
		Если ВершинаСтека > -1 Тогда 
			КусокКода = Стек[ВершинаСтека] + Символы.ПС + Символы.ПС + "Возврат;"; 
		Иначе 
			//когда несколько блоков заканчиваются подряд,
			//то они разделяются символом перевода строки
			//символ перевода строки уменьшает вершину стека
			//Может получится так что вершина ушла в минус
			ВершинаСтека = 0;
			КусокКода = "Возврат;"; 
		КонецЕсли; 
		
		ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);			
		
		Возврат Истина;
		
	КонецЕсли; 
	
	//проверка на "Продолжить"   
	Если (ОперацияПерехода = 39 и ИндПерехода > ИндСледПерехода) или //"Продолжить" в "Для каждого из ТЗ Цикл"
		ОперацияПослеПерехода = 43 или //"Продолжить" в "Для i=0 по 5 Цикл"
		ИндОперации > ИндПерехода Тогда //"Продолжить" в "Пока Условие Цикл"
		
		ЗначениеБлока = СоответствиеБлоков.Получить(ИндОперации+1);	
		Если ЗначениеБлока = Неопределено или Найти(ЗначениеБлока, "КонецЦикла") = 0 Тогда
			//Чтобы "Продолжить" не шло после каждого КонецЦикла
			
			Если ВершинаСтека > -1 Тогда 
				КусокКода = Стек[ВершинаСтека] + Символы.ПС + Символы.ПС + "Продолжить;"; 
			Иначе 
				//когда несколько блоков заканчиваются подряд,
				//то они разделяются символом перевода строки
				//символ перевода строки уменьшает вершину стека
				//Может получится так что вершина ушла в минус
				ВершинаСтека = 0;
				КусокКода = "Продолжить;"; 
			КонецЕсли; 
			
			ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);			
		КонецЕсли; 
		
		Возврат Истина;
		
	КонецЕсли; 
	
	//проверка на "Прервать"   
	ИндДоПерехода = ИндПерехода-1;
	Если ИндДоПерехода > -1 Тогда
		
		ОперацияПерехода = Операции[ИндДоПерехода].КодОперации;
		ИндСледПерехода = Операции[ИндДоПерехода].Аргумент;
		
		ЗначениеБлока = СоответствиеБлоков.Получить(ИндПерехода);	
		Если ОперацияПерехода = 39 и ИндДоПерехода > ИндСледПерехода и
			ЗначениеБлока <> Неопределено и Найти(ЗначениеБлока, "КонецЦикла") > 0 Тогда
			
			Если ВершинаСтека > -1 Тогда 
				КусокКода = Стек[ВершинаСтека] + Символы.ПС + Символы.ПС + "Прервать;"; 
			Иначе 
				//когда несколько блоков заканчиваются подряд,
				//то они разделяются символом перевода строки
				//символ перевода строки уменьшает вершину стека
				//Может получится так что вершина ушла в минус
				ВершинаСтека = 0;
				КусокКода = "Прервать;"; 
			КонецЕсли; 
			
			ДобавитьВСтек(Стек, ВершинаСтека, 0, КусокКода);			
			
			Возврат Истина;
			
		КонецЕсли; 
	КонецЕсли; 
	
	Возврат Ложь;
	
КонецФункции

Функция БулевоСкобкиНужны(Знач ИндОперации, Знач КодОперации, Стек, ВершинаСтека)
				
	Нужны = Ложь; 
	
	ПроверкаВпередВершинаСтека = ВершинаСтека;
	
	ИсходныйКодОперации = КодОперации;
	
	Если КодОперации = 69 Тогда

		Если Стек[ВершинаСтека-1] = "И" Тогда
			КодОперации = 30;
		ИначеЕсли Стек[ВершинаСтека-1] = "ИЛИ" Тогда 
			КодОперации = 31; 
		Иначе 
			ВызватьИсключение СтрШаблон("Не предусмотрен оператор %1 в вычислении будево", Стек[ВершинаСтека-1]);
		КонецЕсли; 
		
		ВершинаСтекаСледОперации = ВершинаСтека-3;
	Иначе 		
		ВершинаСтекаСледОперации = ВершинаСтека-1;
	КонецЕсли; 
	
	ТекущийПриоритет = ПриоритетыОпераций.Получить(КодОперации);
	
	Если ТекущийПриоритет = Неопределено Тогда 
		ВызватьИсключение СтрШаблон("У кода операции %1 не определен приоритет", КодОперации);	
	КонецЕсли;
				
	СледИндОперации = ИндОперации+1;          
	
	Пока Истина Цикл  
				      
		СледКодОперации = Операции[СледИндОперации].КодОперации;
		
		Если СледКодОперации = 1 Тогда
			Прервать;	
		КонецЕсли;  
		
		Если СледКодОперации <> 30 И СледКодОперации <> 31 И СледКодОперации <> 69 И СледКодОперации <> 29 Тогда
			СледИндОперации = СледИндОперации + 1;   
			Продолжить;
		КонецЕсли; 
		
		СледОперация69 = Ложь;
		        
		Если СледКодОперации = 69 Тогда
			
			СледОперация69 = Истина;
			
			Если Стек[ВершинаСтекаСледОперации] = "И" Тогда
				СледКодОперации = 30;
			ИначеЕсли Стек[ВершинаСтекаСледОперации] = "ИЛИ" Тогда 
				СледКодОперации = 31; 
			Иначе 
				ВызватьИсключение СтрШаблон("Не предусмотрен оператор %1 в вычислении булево", Стек[ВершинаСтекаСледОперации]);
			КонецЕсли; 

		КонецЕсли;    
				
		СледПриоритет = ПриоритетыОпераций.Получить(СледКодОперации);
		
		Если СледПриоритет <> Неопределено Тогда
			
			Если СледПриоритет < ТекущийПриоритет Тогда 
				Нужны = Истина;
			ИначеЕсли СледПриоритет = ТекущийПриоритет и СледОперация69 Тогда 
				Нужны = Истина;  
			КонецЕсли; 
			
		КонецЕсли; 
		
		Прервать;
		
	КонецЦикла;
	
	Возврат Нужны;

КонецФункции

Процедура УстановитьСкобкиПредыдущимЧленам(Знач ИндОперации, Знач КодОперации, Стек, ВершинаСтека)
		
	Нужны = Ложь;
	ИзменитьВершинуСтека = Истина;
		
	ТекущийПриоритет = ПриоритетыОпераций.Получить(КодОперации);
	
	Если ТекущийПриоритет = Неопределено Тогда 
		ВызватьИсключение СтрШаблон("У кода операции %1 не определен приоритет", КодОперации);	
	КонецЕсли;
	
	ПредКодОперации = Операции[ИндОперации-1].КодОперации;
	
	ПредПриоритет = ПриоритетыОпераций.Получить(ПредКодОперации);
	
	Если ПредПриоритет = Неопределено Тогда
		ИзменитьВершинуСтека = Ложь;
		
		ПредИндекс = ИндОперации-2;
		
		Пока Истина Цикл
			
			ПредКодОперации = Операции[ПредИндекс].КодОперации;
			
			Если ПредКодОперации = 1 Тогда
				
				Прервать;	
				
			КонецЕсли; 
			
			ПредПриоритет = ПриоритетыОпераций.Получить(ПредКодОперации);
			
			Если ПредПриоритет <> Неопределено Тогда
				
				Прервать;	
				
			КонецЕсли; 
			ПредИндекс = ПредИндекс -1;
			
		КонецЦикла;
	КонецЕсли;
	
	Если ПредПриоритет <> Неопределено И ПредПриоритет >= ТекущийПриоритет Тогда 
		Нужны = Истина;
	КонецЕсли; 
	
	Если Нужны Тогда
				
		Если ПредПриоритет > ТекущийПриоритет и
			СтрНайти(Стек[ВершинаСтека-1], "+") > 0 или
			СтрНайти(Стек[ВершинаСтека-1], "-") > 0 или
			СтрНайти(Стек[ВершинаСтека-1], "*") > 0 или
			СтрНайти(Стек[ВершинаСтека-1], "/") > 0 или
			СтрНайти(Стек[ВершинаСтека-1], "%") > 0
			Тогда 
			
			Стек[ВершинаСтека-1] = СтрШаблон("(%1)", Стек[ВершинаСтека-1]);	
			
		КонецЕсли;
		
		Если ИзменитьВершинуСтека Тогда
			
			Стек[ВершинаСтека] = СтрШаблон("(%1)", Стек[ВершинаСтека]);	
			
		КонецЕсли; 
		
	КонецЕсли;       
	
КонецПроцедуры
